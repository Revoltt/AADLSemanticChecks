AADL Specifications	p41n1	(N1)  An AADL specification has one global namespace. The package and property set identifiers reside in this space and must be unique.	
AADL Specifications	p41n2	(N2)  These package and property set identifiers qualify the names of individual elements contained in them when they are referenced.	
AADL Specifications	p41n3	(N3)  Package declarations represent labeled namespaces for component type, component implementation, feature group type, and annex library declarations.	
AADL Specifications	p41n4	(N4)  Property set declarations represent labeled namespaces for property type and property definition declarations.	
AADL Specifications	p41n5	(N5)  Packages and property sets may be separately stored. Those packages and property sets are considered to be part of the global namespace.	
AADL Specifications	p41n6	(N6)  Defining identifiers in AADL must not be one of the reserved words of the language (see Section 15.7).	
AADL Specifications	p41n7	(N7)  The AADL identifiers and reserved words can be in upper or lower case (or a mixture of the two) (see Section 15).	
AADL Specifications	p41n8	(N8)  The AADL does not require that an identifier be declared before it is referenced.	NO
Packages	p42n1	(N1)  A defining package name consists of a sequence of one or more package identifiers separated by a double colon (“::”). A defining package name must be unique in the global namespace.	NO
Packages	p42n2	(N2)  The public and private section of a package may be declared in separate package declarations; these two declarations introduce a single defining package name.	NO
Packages	p42n3	(N3)  Associated with every package is a package namespace that contains the names for all the elements defined within that package. This means that component types, feature group types, and defining entities declared in an annex library using an annex-specific sublanguage can be declared with the same name in different packages.	NO
Packages	p42n4	(N4)  The package namespace is divided into a public section and a private section. Items declared in the public section of the package namespace can be referenced from outside the package as well as within the package.	NO
Packages	p42n5	(N5)  The reference to an item declared in another package must be an item name qualified with a package name separated by a double colon (“::”). The package name must be listed in the import_declaration (with) of the package with the reference, i.e., in the import_declaration of the public section, if the reference is in the public section, and in the import_declaration of the public or private section if the reference is in the private section of the package. Only classifiers in the public package section can be referenced. SAE AS5506B - 32 - Note: References to items declared in the same package as the reference do not have to be qualified. If they are quailified the package is not required to be listed in the import_declaration.	NO
Packages	p42n6	(N6)  The reference to a property other than predeclared properties must be an property name qualified with a property set name separated by a double colon (“::”). The property set name must be listed in the with declaration of the package with the reference. Predeclared properties may be, but are not required to be qualified by the property set name.	NO
Packages	p42n7	(N7)  The package name in a import_declaration must exist in the global name space.	NO
Packages	p42n8	(N8)  The property set identifier in a import_declaration must exist in the global name space.	NO
Packages	p42n9	(N9)  Items declared in the private section of the package can only be referenced from within the private section of the package.	NO
Packages	p42n10	(N10) If the qualifying package identifier of a qualified reference is missing, the referenced component classifier, feature  group type, or item in an annex library must exist in the same package as the reference.	NO
Packages	p42n11	(N11) The package name referenced in an alias_declaration must exist in the global namespace and must be  listed in the import_declaration.	NO
Packages	p42n12	(N12) The classifier referenced by the alias_declaration must exist in the name space of the public section of the  package being referenced by the alias_declaration.	NO
Packages	p42n13	(N13) The classifier referenced by the alias declaration must refer to a component type or a feature group type. 	NO
Packages	p42n14	(N14) The defining identifier of an alias_declaration must be unique in the namespace of the package containing  the alias_declaration. If an alias_declaration defines an alias for a package then the alias name must not conflict with any package name listed in an import_declaration or that of the package containing the alias_declaration.	NO
Packages	p42n15	(N15) The alias_declaration makes the publicly visible identifier of classifiers declared in another package  accessible in the name space of the package containing the alias_declaration. If the alias declaration for a classifier does not include a defining identifier then the referenced classifier identifier is used as defining identifier and this identifier must be unique in the namespace of the package with the alias declaration.	NO
Packages	p42n16	(N16) If the alias_declaration renames all publicly visible identifiers of component types and feature group types  by naming the package and all, then all those identifiers must also be unique in the namespace of the package with the alias declaration.	NO
Packages	p42n17	(N17) The identifiers introduced by the alias_declaration are only accessible within the package. When declared in  the public package section, they can be referenced within the public and private package section, but not from other packages. When declared in the private package section, they can be referenced within the private package section only.	NO
Packages	p42n18	(N18) The alias declared for a component type can be used instead of a qualified component type in a reference to a  component implementation. Legality Rules	NO
Packages	p42l1	(L1)  The defining package name following the reserved word end must be identical to the defining package name following the reserved word package.	NO
Packages	p42l2	(L2)  For each package there may be at most one public section declaration and one private section declaration. These two sections may be declared in a single package declaration or in two separate package declarations.	NO
Packages	p42l3	(L3)  A component implementation may be declared in both the public and private part of a package. In that case the declaration in the public part may only contain a properties subclause and a modes subclause. SAE	NO
Packages	p42l4	(L4)  AS5506B - 33 - The component category in an alias declaration must match the category of the referenced component type.	NO
Component Types	p43n1	(N1)  The defining identifier for a component type must be unique in the namespace of the package within which it is declared.	NO
Component Types	p43n2	(N2)  Each component type has a local namespace for defining identifiers of prototypes, features, modes, mode transitions, and flow specifications. That is, defining prototype, defining feature, defining modes and mode transitions, and defining flow specification identifiers must be unique in the component type namespace.	NO
Component Types	p43n3	(N3)  The component type identifier of the ancestor in a component type extension, i.e., that appears after the reserved word extends, must be defined in the specified package namespace. If no package name is specified, then the identifier must be defined in the namespace of the package the extension is declared in.	NO
Component Types	p43n4	(N4)  When a component type extends another component type, a component type namespace includes all the identifiers in the namespaces of its ancestors.	NO
Component Types	p43n5	(N5)  A component type that extends another component type does not include the identifiers of the implementations of its ancestors.	NO
Component Types	p43n6	(N6)  The defining identifier of a feature, flow specification, mode, mode transition, or prototype must be unique in the namespace of the component type.	NO
Component Types	p43n7	(N7)  The refinement identifier of a feature, flow specification, or prototype refinement refers to the closest refinement or the defining declaration of the feature going up the component type ancestor hierarchy.	NO
Component Types	p43n8	(N8)  The prototypes referenced by prototype binding declarations must exist in the local namespace of the component type being extended.	NO
Component Types	p43n9	(N9)  Mode transitions declared in the component type may not refer to event or event data ports of subcomponents. SAE AS5506B - 37 - Legality Rules	NO
Component Types	p43l1	(L1)  The defining identifier following the reserved word end must be identical to the defining identifier that appears after the component category reserved word.	NO
Component Types	p43l2	(L2)  The prototypes, features, flows, modes, and properties subclauses are optional. If a subclause is present but empty, then the reserved word none followed by a semi-colon must be present.	NO
Component Types	p43l3	(L3)  The category of the component type being extended must match the category of the extending component type, i.e., they must be identical or the category being extended must be abstract.	NO
Component Types	p43l4	(L4)  The classifier being extended in a component type extension may include prototype bindings. There must be at most one prototype binding for each prototype, i.e., once bound a prototype binding cannot be overwritten by a new binding in a component type extension.	NO
Component Types	p43l5	(L5)  A component type must not contain both a requires_modes_subclause and a modes_subclause.	NO
Component Types	p43l6	(L6)  If the extended component type and an ancestor component type in the extends hierachy contain modes subclauses, they must both be requires_modes_subclause or modes_subclause. Standard Properties Classifier_Substitution_Rule: inherit enumeration (Classifier_Match, Signature_Match) Type_Extension, Prototype_Substitution_Rule: inherit enumeration (Classifier_Match, Type_Extension, Signature_Match)	NO
Component Implementations	p44n1	(N1)  A component implementation name consists of a component type identifier and a component implementation identifier separated by a dot (“.”). The first identifier of the defining component implementation name must name a component type that is declared in the same package as the component implementation, or name an alias to a component type in another package.	NO
Component Implementations	p44n2	(N2)  The defining identifier of the component implementation must be unique within the local namespace of the component type.	NO
Component Implementations	p44n3	(N3)  Every component implementation defines a local namespace for all defining identifiers of prototypes, subcomponents, subprogram calls, connections, flows, and modes declared within the component implementation. The defining identifier of a prototype, subcomponent, subprogram call, connection, flow, or mode must be unique within this namespace. For example, a subcomponent and a mode cannot have the same defining identifier within the same component implementation, or a mode with the same defining identifier cannot be declared in a component type and a component implementation.	NO
Component Implementations	p44n4	(N4)  This local namespace inherits the namespace of the associated component type, i.e., defining identifiers must be unique within the local namespace and also within the component type namespace.	NO
Component Implementations	p44n5	(N5)  Refinement identifiers of features must exist in the namespace of the associated component type or one of the component type’s ancestors. Refinement identifiers of prototype, subcomponent, and connection refinements must exist in the local namespace of an ancestor component implementation.	NO
Component Implementations	p44n6	(N6)  In a component implementation extension, the component type identifier of the component implementation being extended, which appears after the reserved word extends, must be the same as or an ancestor of the component type of the extension. The component implementation being extended may exist in another package. In this case the component implementation name is qualified with the package name.	NO
Component Implementations	p44n7	(N7)  When a component implementation extends another component implementation, the local namespace of the extension is a superset of the local namespace of the ancestor. That is, the local namespace of a component implementation inherits all the identifiers in the local namespaces of its ancestors (including the identifiers of their respective component type namespaces). SAE AS5506B - 42 -	NO
Component Implementations	p44n8	(N8)  Within the scope of the component implementation, subcomponent declarations, connections, subprogram call sequences, mode transitions, and property associations can refer directly to identifiers in the local namespace, i.e., to declared prototypes, subcomponents, connections, and modes, as well as to required bus, data, subprogram, and subprogram group subcomponents and features declared in the associated component type.	NO
Component Implementations	p44n9	(N9)  The prototype referenced by the prototype binding declaration must exist in the local namespace of the component implementation being extended. In other words, prototype binding declarations may bind prototypes of the component type and of the component implementation. NOTES: A component type can be made visible in a new namespace (package) without qualifying it with the package name by declaring it as renames that refers to the component type in the original package. This allows an implementation to be placed in a separate package from the component type package. In the following example, renames LM::GPS allows the type GPS to be named without a qualifying package name. This allows a system implementation to be added to GPS in the package LM1. package LM1 public renames LM::GPS; system implementation GPS.newimpl Legality Rules	NO
Component Implementations	p44l1	(L1)  The pair of identifiers separated by a dot (“.”) following the reserved word end must be identical to the pair of identifiers following the reserved word implementation.	NO
Component Implementations	p44l2	(L2)  The prototypes, subcomponents, connections, calls, flows, modes, and properties subclauses are optional. If they are present and the set of feature or required subcomponent declarations or property associations is empty, none followed by a semi-colon must be present in that subclause.	NO
Component Implementations	p44l3	(L3)  The category of the component implementation must be identical to the category of the component type for which the component implementation is declared.	NO
Component Implementations	p44l4	(L4)  If the component implementation extends another component implementation, the category of both must match, i.e., they must be identical or the category being extended must be abstract.	NO
Component Implementations	p44l5	(L5)  The classifier being extended in a component implementation extension may include prototype bindings. There must be at most one prototype binding for each unbound prototype.	NO
Component Implementations	p44l6	(L6)  If the component type of the component implementation contains a requires_modes_subclause then the component implementation must not contain any modes subclause.	NO
Component Implementations	p44l7	(L7)  If modes are declared in the component type, then modes cannot be declared in component implementations.	NO
Component Implementations	p44l8	(L8)  If modes or mode transitions are declared in the component type, then mode transitions can be added in the component implementation. These mode transitions may refer to event or event data ports of the component type and of subcomponents.	NO
Component Implementations	p44l9	(L9)  The category of a subcomponent being refined must match the category of the refining subcomponent declaration, i.e., they must be identical or the category being refined must be abstract.	NO
Component Implementations	p44l10	(L10) For all other refinement declarations the categories must match (see the respective sections). 	NO
Component Implementations	p44l11	(L11) Component implementations and component implementation extensions must not refine prototypes declared in a  component type. SAE AS5506B - 43 - Standard Properties Classifier_Substitution_Rule: inherit enumeration (Classifier_Match, Signature_Match) Type_Extension, Prototype_Substitution_Rule: inherit enumeration (Classifier_Match, Type_Extension, Signature_Match) Classifier_Matching_Rule: inherit enumeration (Classifier_Match, Equivalence, Subset, Conversion, Complement)	NO
Subcomponents	p45n1	(N1)  The defining identifier of a subcomponent declaration placed in a component implementation must be unique within the local namespace of the component implementation that contains the subcomponent.	NO
Subcomponents	p45n2	(N2)  The defining identifier of a subcomponent refinement must exist as a defining subcomponent identifier in the local namespace of an ancestor component implementation.	NO
Subcomponents	p45n3	(N3)  The component type identifier or the component implementation name of a component classifier reference must exist in the package namespace.	NO
Subcomponents	p45n4	(N4)  The prototype identifier of a prototype reference must exist in the local name space of the component implementation.	NO
Subcomponents	p45n5	(N5)  The prototype referenced by the prototype binding declarations must exist in the local namespace of the component classifier being referenced.	NO
Subcomponents	p45n6	(N6)  The modes named in the in modes statement of a subcomponent must refer to modes in the component implementation that contains the subcomponent or its component type. The modes named in the in modes statement of a property association of a subcomponent must refer to modes of the subcomponent, or in the case of a contained property association to modes of the last component in the component path (see Section 11.3). Legality Rules	NO
Subcomponents	p45l1	(L1)  The category of the subcomponent declaration must match the category of its corresponding component classifier reference or its prototype reference, i.e., they must be identical, or in the case of a classifier reference the referenced classifier category may be abstract.	NO
Subcomponents	p45l2	(L2)  The component classifier reference of a subcomponent declaration may include prototype bindings for a subset or all of the component classifier prototypes. This represents an unnamed component classifier extension of the referenced classifier.	NO
Subcomponents	p45l3	(L3)  In a subcomponent refinement declaration the component category may be refined from abstract to one of the concrete component categories. Otherwise the category must be the same as that of the subcomponent being refined.	NO
Subcomponents	p45l4	(L4)  The Classifier_Substitution_Rule property specifies the rule to be applied when a refinement supplies a classifier and the original subcomponent declaration already has a component classifier. This property can be applied to individual subcomponents or features, or it can be inherited from classifiers. The following rules are supported: • • • Classifier_Match: The component type of the refinement must be identical to the component type of the classifier being refined. If the original declaration specifies a component implementation, then any implementation of that type can replace this original implementation. This is the default rule. Type_Extension: Any component classifier whose component type is an extension of the component type of the classifier in the subcomponent being refined is an acceptable substitute. Signature_Match: The component type of the refinement must match the signature of the component type of the classifier being refined. SAE AS5506B - 48 -	NO
Subcomponents	p45l5	(L5)  In the case of a signature match, the component type of the subcomponent being refined must have a subset of the features of the component type in the refinement. The features are compared by name matching; the feature categories and direction (in data port, provides data access, etc.) must be the same and any feature classifier must match according to rules defined for Classifier_Match. In addition, if flow specifications are present in the component type being refined, then the component type of the refinement must have at least the same set of flow specifications. Flow specifications with the same name must have the same source and destination ports.	NO
Subcomponents	p45l6	(L6)  The component category and optional component classifier or prototype reference can be followed by a set of array dimensions to define the subcomponent as an array of actual subcomponents.	NO
Subcomponents	p45l7	(L7)  The array size specification for the dimensions is optional. In this case the array declaration is considered incomplete. If the size of the array dimension is specified it must be specified for all dimensions in the same declaration.	NO
Subcomponents	p45l8	(L8)  When refining a subcomponent array the number of dimensions of the array cannot be changed, but the array size can be specified for each dimension if it was not specified in the subcomponent declaration being refined.	NO
Subcomponents	p45l9	(L9)  When the subcomponent is declared as an array with array dimension sizes then a list of component implementations can be supplied, one for each element of the array. Different implementations of the same component type can be chosen. The number of elements in the list must correspond to the number of elements in the component array. In the case of multi-dimensional arrays, the list elements are assigned by incrementing the index of the last dimension first.	NO
Subcomponents	p45l10	(L10) Selecting index ranges in one or more dimensions of an array is only possible if the size of the array for these  dimensions is already defined. The index range of a dimension is from 1 to the size of the dimension. Specification of array index ranges is limited to the applies to subclause of contained property associations. Specification of a single array element is limited to the applies to subclause of contained property associations and to the values of reference properties.	NO
Subcomponents	p45l11	(L11) An array element implementation list is valid only if (a) the subcomponent classifier is a component type and (b) all  component implementations in the list are implementations of the specified type. Consistency Rules	NO
Subcomponents	p45c1	(C1) The classifier of a subcomponent cannot recursively contain subcomponents with the same component classifier.  In other words, there cannot be a cyclic containment dependency between components. Standard Properties Classifier_Substitution_Rule: inherit enumeration (Classifier_Match, Signature_Match) Type_Extension, Acceptable_Array_Size: list of Size_Range	NO
Abstract Components	p46l1	(L1)  An abstract component type declaration can contain feature declarations (including abstract feature declarations), flow declarations, as well as property associations.	NO
Abstract Components	p46l2	(L2)  An abstract component implementation can contain subcomponent declarations of any category. Certain combinations of subcomponent categories are only acceptable if they are acceptable in one of the concrete component categories.	NO
Abstract Components	p46l3	(L3)  An abstract component implementation can contain a modes subclause, a connections subclause, a flows subclause, and property associations.	NO
Abstract Components	p46l4	(L4)  An abstract subcomponent can be contained in the implementation of any component category.	NO
Abstract Components	p46l5	(L5)  If an abstract subcomponent is refined to a concrete category, the concrete category must be acceptable to the component implementation category whose subcomponent is being refined.	NO
Abstract Components	p46l6	(L6)  An abstract subcomponent can be declared as an array of subcomponents.	NO
Abstract Components	p46l7	(L7)  If an abstract component type is refined to a concrete category, the features, modes, and flow specifications of the abstract component type must be acceptable for the concrete component type. SAE	NO
Abstract Components	p46l8	(L8)  AS5506B - 54 - If an abstract component implementation is refined to a concrete category, the subcomponents, call sequences, modes, flow implementations, and end-to-end flows of the abstract component implementation must be acceptable for the concrete component implementation. Standard Properties (2) An abstract component can have property associations of properties that apply to any concrete category. However, when refined to a concrete category, properties that do not apply to the concrete category will be ignored. A method of processing may provide a warning about ignored properties.	NO
Prototypes	p47n1	(N1)  The prototype identifier on the left-hand side of a prototype binding must exist in the local namespace of the classifier for which the prototype binding is defined.	NO
Prototypes	p47n2	(N2)  The prototype identifier on the right-hand side of a prototype binding, if present, must exist in the local namespace of the classifier that contains the prototype binding. SAE AS5506B - 57 -	NO
Prototypes	p47n3	(N3)  Unique component classifier references must exist in the public section of the package being identified in the reference.	NO
Prototypes	p47n4	(N4)  Unique feature group type references must exist in the public section of the package being identified in the reference. Legality Rules	NO
Prototypes	p47l1	(L1)  The component category declared in the component prototype binding must match the component category of the prototype being referenced, i.e., they must be identical, or the declared category component category of the prototype must be abstract.	NO
Prototypes	p47l2	(L2)  The component category of the optional component classifier reference in the prototype declaration must match the category in the prototype declaration.	NO
Prototypes	p47l3	(L3)  If the component prototype only specifies a component category, then any component type and component implementation of that category is acceptable; in the case of the category abstract any component type and component implementation of any category is acceptable.	NO
Prototypes	p47l4	(L4)  If the component prototype declaration includes a component classifier reference, then the classifier supplied in the prototype binding must match according to the Prototype_Substitution_Rule property. This property specifies the rules to be applied to determine an acceptable classifier supplied to the prototype. This property can be associated with a prototype declaration or the enclosing component type or component implementation. The rules are the same as those of the Classifier_Substitution_Rule property.	NO
Prototypes	p47l5	(L5)  The category of the component implementation that contains the prototype declaration places restrictions on the set of acceptable categories for the prototype declaration and the supplied classifiers. The nesting rules for each category are defined in the respective component category section of this document. For example, if the component implementation is a thread group implementation, then the prototype referenced in a subcomponent declaration must be of the category thread group, thread, subprogram, subprogram group, data, or abstract.	NO
Prototypes	p47l6	(L6)  If the direction is declared for feature prototypes, then the prototype actual satisfies the direction according to the same rules as for feature refinements (see Section 8); in the case of ports the direction must be in or out; in the case of data access, the access right must be read-only for in and write-only for out; in the case of bus access, subprogram access and subprogram group access the direction is ignored.	NO
Prototypes	p47l7	(L7)  In the case of feature group prototypes, the supplied feature group types must match the declared feature group type, if any. The Prototype_Substitution_Rule property rules apply to feature group types instead of component types.	NO
Prototypes	p47l8	(L8)  A classifier supplied in a feature prototype binding must match the classifier of the prototype declaration, if present, according to the Prototype_Substitution_Rule property rules.	NO
Prototypes	p47l9	(L9)  Component prototypes declared with square brackets specify that they expect a list of component classifiers. These prototypes can only be referenced in subcomponent array declarations. The component classifier list supplies the classifiers for each of the elements in the component array.	NO
Prototypes	p47l10	(L10) The component category of the classifier reference or prototype reference in a prototype binding declaration must  match the category of the prototype.	NO
Prototypes	p47l11	(L11) If a direction is specified for an abstract feature in a prototype declaration, then the direction of the prototype actual  must match that declared in the prototype.	NO
Prototypes	p47l12	(L12) Component prototype bindings must only bind component prototypes, feature group prototype bindings must only  bind feature group prototypes, and feature bindings must only bind feature prototypes.	NO
Prototypes	p47l13	(L13) Component prototype refinements must only refine component prototypes, feature group prototype refinements  must only refine feature group prototypes, and feature refinements must only refine feature prototypes. SAE AS5506B - 58 - Standard Properties Prototype_Substitution_Rule: inherit enumeration (Classifier_Match, Type_Extension, Signature_Match)	NO
Annex Subclauses and Annex Libraries	p48n1	(N1)  The annex identifier must be the name of an approved annex or a project-specific identifier different from the approved annex identifiers.	NO
Annex Subclauses and Annex Libraries	p48n2	(N2)  The mode identifiers in the in_modes statement must refer to modes in the component type or component implementation for which the annex subclause is declared. Legality Rules	NO
Annex Subclauses and Annex Libraries	p48l1	(L1)  Annex subclauses can only be declared in component types, component implementations, and feature group types.	NO
Annex Subclauses and Annex Libraries	p48l2	(L2)  A component type, component implementation, or feature group type declaration may contain at most one annex subclause for each annex. If the annex subclause has an in_modes statement, then there must be at most one annex subclause per mode for each annex.	NO
Annex Subclauses and Annex Libraries	p48l3	(L3)  Annex libraries must be declared in packages.	NO
Annex Subclauses and Annex Libraries	p48l4	(L4)  A package declaration may contain at most one annex library declaration for each annex.	NO
Data	p51l1	(L1)  A data type declaration can contain provides subprogram access declarations as well as property associations.	NO
Data	p51l2	(L2)  A data type declaration must not contain a flow specification or modes subclause.	NO
Data	p51l3	(L3)  A data implementation can contain abstract, data and subprogram subcomponents, access connections, and data property associations.	NO
Data	p51l4	(L4)  A data implementation must not contain a flow implementation, an end-to-end flow specification, or a modes subclause. Standard Properties Source_Data_Size: Size Source_Code_Size: Size Type_Source_Name: aadlstring Source_Name: aadlstring Source_Text: inherit list of aadlstring -- hardware mapping Base_Address: aadlinteger 0 .. Max_Base_Address Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Actual_Memory_Binding: inherit list of reference (memory) -- Data sharing properties Access_Right : Access_Rights => read_write Concurrency_Control_Protocol: Supported_Concurrency_Control_Protocols SAE (5) AS5506B - 64 - The value of the Type_Source_Name property identifies the name of the data type declaration in the source text. The value of the Source_Name property identifies the name of the static or local data variable in the source text.	NO
Subprograms and Subprogram Calls	p52n1	(N1)  The defining identifier of a subprogram call sequence declaration must be unique within the local namespace of the component implementation that contains the subprogram call sequence.	NO
Subprograms and Subprogram Calls	p52n2	(N2)  The defining identifier of a subprogram call declaration must be unique within the local namespace of the component implementation that contains the subprogram call.	NO
Subprograms and Subprogram Calls	p52n3	(N3)  If the called subprogram name is a subprogram classifier reference, its component type identifier or component implementation name must exist in the package namespace. SAE AS5506B - 70 -	NO
Subprograms and Subprogram Calls	p52n4	(N4)  The subprogram classifier reference of a subprogram call may be a subprogram type reference.	NO
Subprograms and Subprogram Calls	p52n5	(N5)  If the called subprogram name is a subprogram subcomponent reference, the subprogram subcomponent must exist in the component implementation containing the subprogram call declaration.	NO
Subprograms and Subprogram Calls	p52n6	(N6)  If the called subprogram name is a requires subprogram access reference, the requires subprogram access must exist in the component type of the component implementation containing the subprogram call declaration. Legality Rules Category subprogram Type Features: • out event port • out event data port • feature group • requires data access • requires subprogram access • requires subprogram group access • parameter • feature Flow specifications: yes Modes: yes Properties: yes Implementation Subcomponents: • data • abstract • subprogram Subprogram calls: yes Connections: yes Flows: yes Modes: yes Properties: yes	NO
Subprograms and Subprogram Calls	p52l1	(L1)  A subprogram type declaration can contain parameter, out event port, out event data port, and feature group declarations as well as requires data, subprogram, and subprogram group access declarations. It can also contain a flow specification subclause, a modes subclause, and property associations.	NO
Subprograms and Subprogram Calls	p52l2	(L2)  A subprogram implementation can contain abstract, subprogram, and data subcomponents, a subprogram calls subclause, a connections subclause, a flows subclause, a modes subclause, and property associations.	NO
Subprograms and Subprogram Calls	p52l3	(L3)  Only one subprogram call sequence can apply to a given mode. Consistency Rules	NO
Subprograms and Subprogram Calls	p52c1	(C1) The reference to a provides subprogram access of a processor in a subprogram call (processor .  provides_subprogram_access_identifier) must identify a provides subprogram access feature of the processor that the thread executing the call is bound to.	NO
Subprograms and Subprogram Calls	p52c2	(C2) A subprogram call may reference a subprogram classifier. A project may enforce a consistency rule that this  reference be to a subprogram subcomponent declaration or requires subprogram access declaration. This ensures that a modeler consistently models subprogram calls the same way. Standard Properties -- Properties related to source text Source_Name: aadlstring Source_Text: inherit list of aadlstring Source_Language: inherit list of Supported_Source_Languages Type_Source_Name: aadlstring -- Properties specifying memory requirements of subprograms Source_Code_Size: Size Source_Data_Size: Size Source_Stack_Size: Size SAE AS5506B - 71 - Source_Heap_Size: Size Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Actual_Memory_Binding: inherit list of reference (memory) -- execution related properties Compute_Execution_Time: Time_Range Compute_Deadline: Time Client_Subprogram_Execution_Time: Time_Range Reference_Processor: inherit classifier ( processor ) -- remote subprogram call related properties Urgency: aadlinteger 0 .. Max_Urgency Actual_Subprogram_Call: reference (subprogram) Allowed_Subprogram_Call: list of reference (subprogram) Actual_Subprogram_Call_Binding: list of reference (bus, processor, memory, device) Allowed_Subprogram_Call_Binding: inherit list of reference (bus, processor, device) Subprogram_Call_Type: enumeration (Synchronous, SemiSynchronous) => Synchronous	NO
Subprogram Groups and Subprogram Group Types	p53n1	(N1)  The defining identifier of a subprogram group type must be unique within the package namespace of the package where the subprogram group type is declared.	NO
Subprogram Groups and Subprogram Group Types	p53n2	(N2)  Each subprogram group provides a local namespace. The defining subprogram identifiers of subprogram declarations in a subprogram group type must be unique within the namespace of the subprogram group type.	NO
Subprogram Groups and Subprogram Group Types	p53n3	(N3)  The local namespace of a subprogram group type extension includes the defining identifiers in the local namespace of the subprogram group type being extended. This means, the defining identifiers of subprogram or subprogram group declarations in a subprogram group type extension must not exist in the local namespace of the subprogram group type being extended. The defining identifiers of subprogram or subprogram group refinements in a subprogram group type extension must refer to a subprogram or subprogram group in the local namespace of an ancestor subprogram group type.	NO
Subprogram Groups and Subprogram Group Types	p53n4	(N4)  The defining subprogram identifiers of subprogram access feature declarations in feature group refinements must not exist in the local namespace of any subprogram group being extended. The defining subprogram identifier of subprogram_refinement declarations in subprogram group refinements must exist in the local namespace of any feature group being extended.	NO
Subprogram Groups and Subprogram Group Types	p53n5	(N5)  The package name of the unique subprogram group type reference must refer to a package name in the global namespace. The subprogram group type identifier of the unique subprogram group type reference must refer to a subprogram group type identifier in the named package. SAE AS5506B - 76 - Legality Rules Category Type subprogram group Features: • feature group • provides subprogram access • requires subprogram access • requires subprogram group access • provides subprogram group access • feature Flow specifications: no Modes: no Properties: yes Implementation Subcomponents: • subprogram • subprogram group • data • abstract Subprogram calls: no Connections: yes Flows: no Modes: no Properties: yes	NO
Subprogram Groups and Subprogram Group Types	p53l1	(L1)  A subprogram group type can contain provides and requires subprogram access, and provides and requires subprogram group access.	NO
Subprogram Groups and Subprogram Group Types	p53l2	(L2)  A subprogram group implementation can contain abstract, data, subprogram group, and subprogram subcomponents as well as data and subprogram access connections.	NO
Subprogram Groups and Subprogram Group Types	p53l3	(L3)  A subprogram group type or implementation may contain zero or more subcomponent declarations. If it contains zero elements, then the subprogram group type or implementation is considered to be incompletely specified. Standard Properties -- Port properties defined to be inherit, thus can be associated with a -- feature group to apply to all contained ports. Source_Text: inherit list of aadlstring -- properties related to execution time Reference_Processor: inherit classifier ( processor ) -- Properties specifying memory requirements of subprograms Source_Code_Size: Size Source_Data_Size: Size Source_Stack_Size: Size Source_Heap_Size: Size Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor)	NO
Threads	p54l1	(L1)  A thread type declaration can contain port, feature group, requires data access declarations, as well as requires and provides subprogram access declarations. It can also contain flow specifications, a modes subclause, and property associations.	NO
Threads	p54l2	(L2)  A thread component implementation can contain abstract, data, subprogram, and subprogram group subcomponent declarations, a calls subclause, a flows subclause, a modes subclause, and thread property associations.	NO
Threads	p54l3	(L3)  The Complete out event port, and Error out event data port are predeclared, i.e., are implicitly identifiers in the name space of a thread type. Therefore, there cannot be user-defined features with those names in threads. Consistency Rules	NO
Threads	p54c3	(C3) Either  the Compute_Entrypoint, Compute_Entrypoint_Source_Text Compute_Entrypoint_Call_Sequence property must have a value that indicates the source code to execute after a thread has been dispatched when an implementation is to be generated or consistency with source code is to be checked. Other entrypoint properties are optional, i.e., if a property value is not defined, then the entrypoint is not called.	NO
Threads	p54c4	(C4) The Period property must have a value if the Dispatch_Protocol property value is periodic, sporadic, timed, or  hybrid. Standard Properties -- Properties related to source text Source_Text: inherit list of aadlstring Source_Language: inherit list of Supported_Source_Languages -- Properties specifying memory requirements of threads Source_Code_Size: Size Source_Data_Size: Size Source_Stack_Size: Size Source_Heap_Size: Size -- Properties specifying thread dispatch properties Dispatch_Protocol: Supported_Dispatch_Protocols Dispatch_Trigger: list of reference (port) Dispatch_Able: aadlboolean SAE AS5506B Dispatch_Offset: inherit Time First_Dispatch_Time : inherit Time Period: inherit Time -- the default value of the deadline is that of the period Deadline: inherit Time => Period -- Scheduling properties Priority: inherit aadlinteger POSIX_Scheduling_Policy : enumeration (SCHED_FIFO, SCHED_RR, SCHED_OTHERS) Criticality: aadlinteger Time_Slot: list of aadlinteger -- Properties specifying execution entrypoints and timing constraints Initialize_Execution_Time: Time_Range Initialize_Deadline: Time Initialize_Entrypoint: classifier ( subprogram classifier ) Initialize_Entrypoint_Call_Sequence: reference ( subprogram call sequence ) Initialize_Entrypoint_Source_Text: aadlstring Compute_Execution_Time: Time_Range Compute_Deadline: Time Compute_Entrypoint: classifier ( subprogram classifier ) Compute_Entrypoint_Call_Sequence: reference ( subprogram call sequence ) Compute_Entrypoint_Source_Text: aadlstring Activate_Execution_Time: Time_Range Activate_Deadline: Time Activate_Entrypoint: classifier ( subprogram classifier ) Activate_Entrypoint_Call_Sequence: reference ( subprogram call sequence ) Activate_Entrypoint_Source_Text: aadlstring Deactivate_Execution_Time: Time_Range Deactivate_Deadline: Time Deactivate_Entrypoint: classifier ( subprogram classifier ) Deactivate_Entrypoint_Call_Sequence: reference ( subprogram call sequence ) Deactivate_Entrypoint_Source_Text: aadlstring Recover_Execution_Time: Time_Range Recover_Deadline: Time Recover_Entrypoint: classifier ( subprogram classifier ) Recover_Entrypoint_Call_Sequence: reference ( subprogram call sequence ) Recover_Entrypoint_Source_Text: aadlstring Finalize_Execution_Time: Time_Range Finalize_Deadline: Time Finalize_Entrypoint: classifier ( subprogram classifier ) - 79 - SAE AS5506B - 80 - Finalize_Entrypoint_Call_Sequence: reference ( subprogram call sequence ) Finalize_Entrypoint_Source_Text: aadlstring Reference_Processor: inherit classifier ( processor ) -- mode to enter as result of activation Resumption_Policy: enumeration ( restart, resume ) -- Properties specifying constraints for processor and memory binding Allowed_Processor_Binding_Class: inherit list of classifier (processor, virtual processor, system) Allowed_Processor_Binding: inherit list of reference (processor, virtual processor, system) Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Connection_Binding_Class: inherit list of classifier(processor, virtual processor, bus, virtual bus, device, memory) Allowed_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) Not_Collocated: record ( Targets: list of reference (data, thread, process, system, connection); Location: classifier ( processor, memory, bus, system ); ) Collocated: record ( Targets: list of reference (data, thread, process, system, connection); Location: classifier ( processor, memory, bus, system ); ) -- Binding value filled in by binding tool Actual_Processor_Binding: inherit list of reference (processor, virtual processor) Actual_Memory_Binding: inherit list of reference (memory) Actual_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) -- property indicating whether the thread affects the hyperperiod -- for mode switching Synchronized_Component: inherit aadlboolean => true -- property specifying the action for executing thread at actual mode switch Active_Thread_Handling_Protocol: inherit Supported_Active_Thread_Handling_Protocols => abort Active_Thread_Queue_Handling_Protocol: inherit enumeration (flush, hold) => flush SAE AS5506B - 81 - NOTE: Entrypoints for thread execution can be specified in three ways: by identifying source text name, by identifying a subprogram classifier representing the source text, or by a call sequence. Compute_Entrypoint => classifier ( ControlAlgorithm.basic ); Compute_Entrypoint_Call_Sequence => reference ( callseq1 ); Compute_Entrypoint_Source_Text => “MyControlAlgorithm”;	NO
Thread Groups	p55l1	(L1)  A thread group component type can contain provides and requires data access, as well as port, feature group, provides and requires subprogram access declarations, and provides and requires subprogram group access declarations. It can also contain flow specifications, modes subclauses, and property associations.	NO
Thread Groups	p55l2	(L2)  A thread group component implementation can contain abstract, data, subprogram, subprogram group, thread, and thread group subcomponent declarations.	NO
Thread Groups	p55l3	(L3)  A thread group implementation can contain a connections subclause, a flows subclause, a modes subclause, and properties subclause.	NO
Thread Groups	p55l4	(L4)  A thread group must not contain a subprogram calls subclause. Standard Properties -- Properties related to source text Source_Text: inherit list of aadlstring -- Inheritable thread properties Synchronized_Component: inherit aadlboolean => true Active_Thread_Handling_Protocol: inherit Supported_Active_Thread_Handling_Protocols => abort Period: inherit Time Deadline: inherit Time => Period Dispatch_Offset: inherit Time First_Dispatch_Time : inherit Time -- Scheduling properties Priority: inherit aadlinteger Time_Slot: list of aadlinteger Criticality: aadlinteger SAE AS5506B - 97 - -- execution time related properties Reference_Processor: inherit classifier ( processor ) -- mode related properties Resumption_Policy: enumeration ( restart, resume ) -- startup properties Startup_Deadline: Time Startup_Execution_Time: Time_Range -- Properties specifying constraints for processor and memory binding Allowed_Processor_Binding_Class: inherit list of classifier (processor, virtual processor, system) Allowed_Processor_Binding: inherit list of reference (processor, virtual processor, system) Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Actual_Processor_Binding: inherit list of reference (processor, virtual processor) Actual_Memory_Binding: inherit list of reference (memory) Allowed_Connection_Binding_Class: inherit list of classifier(processor, virtual processor, bus, virtual bus, device, memory) Allowed_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) Actual_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) NOTES: Property associations of thread groups are inheritable (see Section 11.3) by contained subcomponents. This means if a contained thread does not have a property value defined for a particular property, then the corresponding property value for the thread group is used.	NO
Processes	p56l1	(L1)  A process component type can contain port, feature group, provides and requires data access, provides and requires subprogram access declarations, and provides and requires subprogram group access declarations. It can also contain flow specifications, modes subclause, and property associations.	NO
Processes	p56l2	(L2)  A process component implementation can contain abstract, data, subprogram, subprogram group, thread, and thread group subcomponent declarations.	NO
Processes	p56l3	(L3)  A process implementation can contain a connections subclause, a flows subclause, a modes subclause, and a properties subclause.	NO
Processes	p56l4	(L4)  A thread group must not contain a subprogram calls subclause. Consistency Rules	NO
Processes	p56c1	(C1) The complete source text associated with a process component must form a complete and legal program as  defined in the applicable source language standard. This source text shall include the source text that corresponds to the complete set of subcomponents in the process’s containment hierarchy along with the data and subprograms that are referenced by required subcomponent declarations. Standard Properties -- Runtime enforcement of virtual address space boundary Runtime_Protection : inherit aadlboolean -- Properties related to source text Source_Text: inherit list of aadlstring Source_Language: inherit list of Supported_Source_Languages -- Properties related to virtual address space loading Load_Time: Time_Range SAE AS5506B - 99 - Load_Deadline: Time -- Inheritable thread properties Synchronized_Component: inherit aadlboolean => true Active_Thread_Handling_Protocol: inherit Supported_Active_Thread_Handling_Protocols => abort Period: inherit Time Deadline: inherit Time => Period Dispatch_Offset: inherit Time -- execution time related properties Reference_Processor: inherit classifier ( processor ) -- Scheduling related properties Priority: inherit aadlinteger -- mode related properties Resumption_Policy: enumeration ( restart, resume ) Deactivation_Policy: enumeration (inactive, unload) => inactive -- process initialization Startup_Deadline: Time Startup_Execution_Time: Time_Range -- Properties specifying constraints memory binding Allowed_Processor_Binding_Class: inherit list of classifier (processor, virtual processor, system) Allowed_Processor_Binding: inherit list of reference (processor, virtual processor, system) Actual_Processor_Binding: inherit list of reference (processor, virtual processor) Allowed_Connection_Binding_Class: inherit list of classifier(processor, virtual processor, bus, virtual bus, device, memory) Allowed_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) Actual_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Actual_Memory_Binding: inherit list of reference (memory)	NO
Processors	p61l1	(L1)  A processor component type can contain port, feature group, provides subprogram access, provides subprogram group access, and bus access declarations. It may contain flow specifications, a modes subclause, as well as property associations.	NO
Processors	p61l2	(L2)  A processor component implementation can contain declarations of memory, bus, virtual bus, virtual processor, and abstract subcomponents.	NO
Processors	p61l3	(L3)  A processor implementation can contain a modes subclause, flows subclause, and a properties subclause.	NO
Processors	p61l4	(L4)  A processor implementation can contain bus access, subprogram access, subprogram group access, port, feature, and feature group connection declarations.	NO
Processors	p61l5	(L5)  A processor implementation must not contain a subprogram calls subclause. Standard Properties -- Hardware description properties Hardware_Description_Source_Text: inherit list of aadlstring Hardware_Source_Language: Supported_Hardware_Source_Languages -- Properties related to source text that provides thread scheduling services Source_Text: inherit list of aadlstring Source_Language: inherit list of Supported_Source_Languages Source_Code_Size: Size Source_Data_Size: Size Source_Stack_Size: Size Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) -- Processor initialization properties Startup_Deadline: Time Startup_Execution_Time: Time_Range -- Properties specifying provided thread execution support SAE AS5506B Thread_Limit: aadlinteger 0 .. Max_Thread_Limit Allowed_Dispatch_Protocol: list of Supported_Dispatch_Protocols Allowed_Period: list of Time_Range Scheduling_Protocol: inherit list of Supported_Scheduling_Protocols Scheduler_Quantum : inherit Time Slot_Time: Time Frame_Period: Time -- acceptable priority value on threads and mapping into RTOS priority values Priority_Range: range of aadlinteger Priority_Map: list of Priority_Mapping Process_Swap_Execution_Time: Time_Range Thread_Swap_Execution_Time: Time_Range Supported_Source_Language: list of Supported_Source_Languages -- Scaling of processor speed Scaling_Factor : inherit aadlreal Reference_Processor: inherit classifier ( processor ) -- Properties related to data movement in memory Assign_Time: record ( Fixed: Time_Range; PerByte: Time_Range; ) -- Properties related to the hardware clock Clock_Jitter: Time Clock_Period: Time Clock_Period_Range: Time_Range -- Protocol support Provided_Virtual_Bus_Class : inherit list of classifier (virtual bus) Provided_Connection_Quality_Of_Service : inherit list of Supported_Connection_QoS -- mode related properties Resumption_Policy: enumeration ( restart, resume ) Deactivation_Policy: enumeration (inactive, unload) => inactive -- runtime protection support of address spaces Runtime_Protection_Support : aadlboolean -- Virtual machine layering Implemented_As: classifier ( system implementation ) NOTES: - 104 - SAE AS5506B - 105 - The above is the list of the predefined processor properties. Additional processor properties may be declared in user-defined property sets. Candidates include properties that describe capabilities and accuracy of a synchronized clock, e.g., drift rates, differences across processors.	NO
Virtual Processors	p62l1	(L1)  A virtual processor component type can contain port, feature group, provides subprogram access, and subprogram group access declarations. It may contain flow specifications, a modes subclause, as well as property associations.	NO
Virtual Processors	p62l2	(L2)  A virtual processor component implementation can contain declarations of virtual bus, virtual processor, and abstract subcomponents.	NO
Virtual Processors	p62l3	(L3)  A virtual processor implementation can contain a modes subclause, flows subclause, and a properties subclause.	NO
Virtual Processors	p62l4	(L4)  A virtual processor implementation must not contain a subprogram calls subclause.	NO
Virtual Processors	p62l5	(L5)  A virtual processor implementation can contain subprogram access, subprogram group access, port, feature, and feature group connections. Consistency Rules	NO
Virtual Processors	p62c1	(C1) In a fully bound system every virtual processor must be directly or indirectly bound to, or directly or indirectly  contained in a physical processor.	NO
Virtual Processors	p62c2	(C2) In a fully deployed system a requires virtual bus binding of a virtual processor specified by the  Required_Virtual_Bus_Class property must be satisfied by binding the virtual processor to a virtual processor or processor that provides this virtual bus. It is also satisfied if the virtual processor is contained in a processor and the respective virtual bus is bound to the processor. Standard Properties -- Properties related to source text that provides thread scheduling services Source_Text: inherit list of aadlstring Source_Language: inherit list of Supported_Source_Languages Source_Code_Size: Size SAE AS5506B Source_Data_Size: Size Source_Stack_Size: Size Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Actual_Memory_Binding: inherit list of reference (memory) Allowed_Processor_Binding_Class: inherit list of classifier (processor, virtual processor, system) Allowed_Processor_Binding: inherit list of reference (processor, virtual processor, system) Actual_Processor_Binding: inherit list of reference (processor, virtual processor) -- Virtual processor initialization properties Startup_Execution_Time: Time_Range Startup_Deadline: Time -- Properties specifying provided thread execution support Thread_Limit: aadlinteger 0 .. Max_Thread_Limit Allowed_Dispatch_Protocol: list of Supported_Dispatch_Protocols Allowed_Period: list of Time_Range Scheduling_Protocol: inherit list of Supported_Scheduling_Protocols Slot_Time: Time Frame_Period: Time -- acceptable priority value on threads and mapping into RTOS priority values Priority_Range: range of aadlinteger Priority_Map: list of Priority_Mapping Process_Swap_Execution_Time: Time_Range Thread_Swap_Execution_Time: Time_Range Supported_Source_Language: list of Supported_Source_Languages -- Properties of the dispatch characterstics of this virtual processor Period: inherit Time Dispatch_Protocol: Supported_Dispatch_Protocols Execution_Time: Time -- Protocol support Provided_Virtual_Bus_Class : inherit list of classifier (virtual bus) Provided_Connection_Quality_Of_Service : inherit list of Supported_Connection_QoS -- mode related properties Resumption_Policy: enumeration ( restart, resume ) Deactivation_Policy: enumeration (inactive, unload) => inactive -- need for and provision of address space protection Runtime_Protection : inherit aadlboolean Runtime_Protection_Support : aadlboolean -- Virtual machine layering - 108 - SAE AS5506B - 109 - Implemented_As: classifier ( system implementation ) NOTES: The above is the list of the predefined virtual processor properties. Additional processor properties may be declared in user-defined property sets. Candidates include properties that describe capabilities and accuracy of a synchronized clock, e.g., drift rates, differences across processors.	NO
Memory	p63l1	(L1)  A memory type can contain bus access declarations, feature groups, a modes subclause, and property associations. It must not contain flow specifications.	NO
Memory	p63l2	(L2)  A memory implementation can contain abstract, memory, and bus subcomponent declarations.	NO
Memory	p63l3	(L3)  A memory implementation can contain a modes subclause and property associations. SAE AS5506B - 111 -	NO
Memory	p63l4	(L4)  A memory implementation can contain bus access connection declarations. Bus access connections can connect a memory subcomponent to a bus subcomponent or a requires bus access feature, as well as connect a provides bus access feature to a bus subcomponent.	NO
Memory	p63l5	(L5)  A memory implementation must not contain flows subclause, or subprogram calls subclause. Standard Properties -- Properties related memory as a resource and its access Memory_Protocol: read_write enumeration (execute_only, read_only, write_only, read_write) Word_Size: Size => 8 bits Byte_Count: aadlinteger 0 .. Max_Byte_Count Word_Space: aadlinteger 1 .. Max_Word_Space => 1 Base_Address: aadlinteger 0 .. Max_Base_Address Read_Time: record ( Fixed: Time_Range; PerByte: Time_Range; ) Write_Time: record ( Fixed: Time_Range; PerByte: Time_Range; ) -- Hardware description properties Hardware_Description_Source_Text: inherit list of aadlstring Hardware_Source_Language: Supported_Hardware_Source_Languages -- mode related properties Resumption_Policy: enumeration ( restart, resume ) -- Virtual machine layering Implemented_As: classifier ( system implementation )	NO
Buses	p64l1	(L1)  A bus type can have requires bus access declarations, a modes subclause, and property associations.	NO
Buses	p64l2	(L2)  A bus type must not contain any flow specifications.	NO
Buses	p64l3	(L3)  A bus implementation can contain virtual bus and abstract subcomponent declarations.	NO
Buses	p64l4	(L4)  A bus implementation can contain a modes subclause and property associations.	NO
Buses	p64l5	(L5)  A bus implementation must not contain flows subclause, or subprogram calls subclause. Standard Properties -- Properties specifying bus transmission properties Allowed_Connection_Type: list of enumeration (Sampled_Data_Connection, Immediate_Data_Connection, Delayed_Data_Connection, Port_Connection, Data_Access_Connection, Subprogram_Access_Connection) Allowed_Physical_Access_Class: list of classifier ( device, processor, memory, bus ) Allowed_Physical_Access: list of reference ( device, processor, memory, bus ) Allowed_Message_Size: Size_Range Transmission_Type: enumeration ( push, pull ) Transmission_Time: record ( Fixed: Time_Range; PerByte: Time_Range; ) SAE AS5506B - 113 - Prototype_Substitution_Rule: inherit enumeration (Classifier_Match, Type_Extension, Signature_Match) -- Hardware description properties Hardware_Description_Source_Text: inherit list of aadlstring Hardware_Source_Language: Supported_Hardware_Source_Languages Access_Right : Access_Rights => read_write -- Protocol support Provided_Virtual_Bus_Class : inherit list of classifier (virtual bus) Provided_Connection_Quality_Of_Service : inherit list of Supported_Connection_QoS -- mode related properties Resumption_Policy: enumeration ( restart, resume ) -- Virtual machine layering Implemented_As: classifier ( system implementation )	NO
Virtual Buses	p65l1	(L1)  A virtual bus type can have property associations.	NO
Virtual Buses	p65l2	(L2)  A virtual bus type must not contain flow specifications.	NO
Virtual Buses	p65l3	(L3)  A virtual bus implementation can contain virtual bus subcomponent declarations.	NO
Virtual Buses	p65l4	(L4)  A virtual bus implementation can contain a modes subclause and property associations.	NO
Virtual Buses	p65l5	(L5)  A virtual bus implementation must not contain a connections subclause, flows subclause, or subprogram calls subclause. Consistency Rules	NO
Virtual Buses	p65c1	(C1) In a fully deployed system virtual buses must be directly or indirectly bound to processors or buses that support  these virtual buses, or they must be subcomponents of buses and processors. Standard Properties -- Properties specifying bus transmission properties Allowed_Connection_Type: list of enumeration (Sampled_Data_Connection, Immediate_Data_Connection, Delayed_Data_Connection, Port_Connection, Data_Access_Connection, Subprogram_Access_Connection) SAE AS5506B - 116 - Allowed_Message_Size: Size_Range Transmission_Type: enumeration ( push, pull ) Transmission_Time: record ( Fixed: Time_Range; PerByte: Time_Range; ) Prototype_Substitution_Rule: inherit enumeration (Classifier_Match, Type_Extension, Signature_Match) -- Protocol support Provided_Connection_Quality_Of_Service : inherit list of Supported_Connection_QoS Provided_Virtual_Bus_Class : inherit list of classifier (virtual bus) Required_Connection_Quality_Of_Service : inherit list of Supported_Connection_QoS Allowed_Connection_Binding_Class: inherit list of classifier(processor, virtual processor, bus, virtual bus, device, memory) Allowed_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) Actual_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) Required_Virtual_Bus_Class : inherit list of classifier (virtual bus) -- mode related properties Resumption_Policy: enumeration ( restart, resume ) -- Virtual machine layering Implemented_As: classifier ( system implementation )	NO
Devices	p66l1	(L1)  A device type can contain port, feature group, provides subprogram access, provides subprogram group access, bus access declarations, flow specifications, a modes subclause, as well as property associations.	NO
Devices	p66l2	(L2)  A device component implementation must not contain a subprogram calls subclause.	NO
Devices	p66l3	(L3)  A device implementation can contain abstract, data, virtual bus, and bus subcomponents, bus access connections, a modes subclause, a flows subclause, and property associations. Standard Properties -- Hardware description properties Hardware_Description_Source_Text: inherit list of aadlstring Hardware_Source_Language: Supported_Hardware_Source_Languages -- Properties specifying device driver software that must be -- executed by a processor Source_Text: inherit list of aadlstring Source_Language: inherit list of Supported_Source_Languages Source_Code_Size: Size Source_Data_Size: Size SAE AS5506B - 119 - Source_Stack_Size: Size -- Properties specifying the execution properties of the device or its driver Dispatch_Protocol: Supported_Dispatch_Protocols Dispatch_Trigger: list of reference (port) Period: inherit Time Compute_Execution_Time: Time_Range Deadline: inherit Time => Period -- scheduling properties Time_Slot: list of aadlinteger Priority: inherit aadlinteger -- Properties specifying constraints for processor and memory binding -- for the device driver software Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Actual_Memory_Binding: inherit list of reference (memory) Actual_Processor_Binding: inherit list of reference (processor, virtual processor) Allowed_Processor_Binding_Class: inherit list of classifier (processor, virtual processor, system) Allowed_Processor_Binding: inherit list of reference (processor, virtual processor, system) -- protocol support Provided_Virtual_Bus_Class : inherit list of classifier (virtual bus) Provided_Connection_Quality_Of_Service : inherit list of Supported_Connection_QoS -- mode related properties Resumption_Policy: enumeration ( restart, resume ) -- Virtual machine layering Implemented_As: classifier ( system implementation )	NO
Systems	p71l1	(L1)  A system component type can contain subprogram, subprogram group, data and bus access declarations, port, feature group declarations. It can also contain flow specifications as well as property associations.	NO
Systems	p71l2	(L2)  A system component implementation can contain abstract, data, subprogram, subprogram group, process, and system subcomponent declarations as well as execution platform components, i.e., processor, virtual processor, memory, bus, virtual bus, and device.	NO
Systems	p71l3	(L3)  A system implementation can contain a modes subclause, a connections subclause, a flows subclause, and property associations.	NO
Systems	p71l4	(L4)  A thread group must not contain a subprogram calls subclause. Standard Properties -- Properties related to source text Source_Text: inherit list of aadlstring Source_Language: inherit list of Supported_Source_Languages -- Process property that can be specified at the system level as well SAE AS5506B - 123 - -- Runtime enforcement of address space boundaries Runtime_Protection : inherit aadlboolean -- Inheritable thread properties Synchronized_Component: inherit aadlboolean => true Active_Thread_Handling_Protocol: inherit Supported_Active_Thread_Handling_Protocols => abort Period: inherit Time Deadline: inherit Time => Period -- execution time related properties Reference_Processor: inherit classifier ( processor ) -- scheduling properties Time_Slot: list of aadlinteger Priority: inherit aadlinteger -- Properties related binding of software component source text in -- systems to processors and memory Allowed_Processor_Binding_Class: inherit list of classifier (processor, virtual processor, system) Allowed_Processor_Binding: inherit list of reference (processor, virtual processor, system) Actual_Processor_Binding: inherit list of reference (processor, virtual processor) Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Actual_Memory_Binding: inherit list of reference (memory) Allowed_Connection_Binding_Class: inherit list of classifier(processor, virtual processor, bus, virtual bus, device, memory) Allowed_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) Actual_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) Collocated: record ( Targets: list of reference (data, thread, process, system, connection); Location: classifier ( processor, memory, bus, system ); ) Not_Collocated: record ( Targets: list of reference (data, thread, process, system, connection); Location: classifier ( processor, memory, bus, system ); ) -- Properties related systems as execution platforms Hardware_Source_Language: Supported_Hardware_Source_Languages -- mode related properties Resumption_Policy: enumeration ( restart, resume ) -- Properties related to startup of processor contained in a system SAE AS5506B - 124 - Startup_Deadline: Time Startup_Execution_Time: Time_Range -- Properties related to system load times Load_Time: Time_Range Load_Deadline: Time -- Properties related to the hardware clock Clock_Jitter: Time Clock_Period: Time Clock_Period_Range: Time_Range	NO
Systems	p71n1	(N1)  The defining identifier of a feature must be unique within the namespace of the associated component type.	NO
Systems	p71n2	(N2)  Thread features may not be declared using the predeclared ports names Complete or Error.	NO
Systems	p71n3	(N3)  Each refining feature identifier that appears in a feature refinement declaration must also appear in a feature declaration of a component type being extended.	NO
Systems	p71n4	(N4)  A feature is referenced in one of two ways. Within the component implementations for a component type, a feature declared in the type is named in the implementations by its identifier. Within component implementations that contain subcomponents with features, a subcomponent feature is named by the subcomponent identifier and the feature identifier separated by a “.” (dot).	NO
Systems	p71n5	(N5)  The path of a contained property association for a feature must refer to an element of a feature group. Legality Rules	NO
Systems	p71l1	(L1)  Each feature can be refined at most once in the same type extension.	NO
Systems	p71l2	(L2)  A feature refinement declaration of a feature and the original feature must both be declared as port, parameter, access feature, or feature group, or the original feature must be declared as abstract feature.	NO
Systems	p71l3	(L3)  Feature arrays must only be declared for threads, devices, and processors.	NO
Systems	p71l4	(L4)  If the feature refinement specifies an array dimension, then the feature being refined must have an array dimension.	NO
Systems	p71l5	(L5)  If the refinement specifies an array dimension size, then the feature being refined must not have an array dimension size.	NO
Systems	p71l6	(L6)  A contained property association must only be used when the feature is a feature group.	NO
Systems	p71l7	(L7)  In the case of a feature with a classifier reference, the classifier of the refined feature declaration in a component type extension must adhere the classifier refinement rules indicated the Classifier_Substitution_Rule property (see Section 4.5). By default, the Classifier_Match rule applies, i.e., an incomplete classifier reference can be completed. SAE AS5506B - 127 - Standard Properties Acceptable_Array_Size: list of Size_Range Required_Connection_Quality_Of_Service : inherit list of Supported_Connection_QoS Required_Virtual_Bus_Class : inherit list of classifier (virtual bus)	NO
Abstract Features	p81l1	(L1)  The feature direction in a refined feature declaration must be identical to the feature direction in the feature declaration being refined, or the feature being refined must not have a direction.	NO
Abstract Features	p81l2	(L2)  If the direction of an abstract feature is specified, then the direction must be satisfied by the refinement (see also the rules for feature prototypes in Section 4.7); in the case of ports the direction must be in or out; in the case of data access, the access right must be read-only for in and write-only for out; in the case of bus access, subprogram access and subprogram group access the direction must not be in nor out.	NO
Abstract Features	p81l3	(L3)  An abstract feature with a feature prototype identifier and the prototype being referenced must both specify the same direction or no direction.	NO
Abstract Features	p81l4	(L4)  An abstract feature refinement declaration of a feature with a feature prototype reference must only add property associations.	NO
Feature Groups and Feature Group Types	p82n1	(N1)  The defining identifier of a feature group type must be unique within the package namespace of the package where the feature group type is declared.	NO
Feature Groups and Feature Group Types	p82n2	(N2)  Each feature group type provides a local namespace. The defining identifiers of prototype, feature, and feature group declarations in a feature group type must be unique within the namespace of the feature group type.	NO
Feature Groups and Feature Group Types	p82n3	(N3)  The local namespace of a feature group type extension includes the defining identifiers in the local namespace of the feature group type being extended. This means, the defining identifiers of prototype, feature, or feature group declarations in a feature group type extension must not exist in the local namespace of the feature group type being extended. The defining identifiers of prototype, feature, or feature group refinements in a feature group type extension must refer to a prototype, feature, or feature group in the local namespace of an ancestor feature group type.	NO
Feature Groups and Feature Group Types	p82n4	(N4)  The defining feature identifiers of feature group declarations must be unique in the local name space of the component type containing the feature group declaration.	NO
Feature Groups and Feature Group Types	p82n5	(N5)  The defining feature group identifier of feature_refinement declarations in component types must exist in the local namespace of the component type being extended and must refer to a feature or feature group. SAE AS5506B - 130 -	NO
Feature Groups and Feature Group Types	p82n6	(N6)  The package name of the unique feature group type reference must refer to a package name in the global namespace. The feature group type identifier of the unique feature group type reference must refer to a feature group type identifier in the named package.	NO
Feature Groups and Feature Group Types	p82n7	(N7)  The prototype reference in a feature group declaration must refer to a prototype of the component type or feature group type that contains the feature group declaration. Legality Rules	NO
Feature Groups and Feature Group Types	p82l1	(L1)  A feature group type may contain zero or more elements, i.e., feature or feature groups. If it contains zero elements, then the feature group type may be declared to be the inverse of another feature group type.	NO
Feature Groups and Feature Group Types	p82l2	(L2)  A feature group type can be declared to be the inverse of another feature group type, as indicated by the reserved words inverse of and the name of a feature group type. Any feature group type named in an inverse of statement cannot itself contain an inverse of statement. This means that several feature groups can be declared to be the inverse of one feature group, e.g., B inverse of A and C inverse of A is acceptable. However, chaining of inverses is not permitted, e.g., B inverse of A and C inverse of B is not acceptable.	NO
Feature Groups and Feature Group Types	p82l3	(L3)  Only feature group types without inverse of or feature group types with features and inverse of can be extended.	NO
Feature Groups and Feature Group Types	p82l4	(L4)  A feature group type that is an extension of another feature group type without an inverse of cannot contain an inverse of statement.	NO
Feature Groups and Feature Group Types	p82l5	(L5)  The feature group type that is an extension of another feature group type with features and inverse of that adds features must have an inverse of to identify the feature group type whose inverse it is.	NO
Feature Groups and Feature Group Types	p82l6	(L6)  A feature group declaration with an inverse of statement must only reference feature group types without an inverse of statement.	NO
Feature Groups and Feature Group Types	p82l7	(L7)  A feature group refinement may be refined to only add property associations. In this case inclusion of the feature group type reference is optional. Two feature group types are considered to complement each other if the following holds:	NO
Feature Groups and Feature Group Types	p82l8	(L8)  The number of feature or feature groups contained in the feature group and its complement must be identical;	NO
Feature Groups and Feature Group Types	p82l9	(L9)  Each of the declared features or feature groups in a feature group must be a pair-wise complement with that in the feature group complement, with pairs determined by declaration order. In the case of feature group type extensions, the feature and feature group declarations in the extension are considered to be declared after the declarations in the feature group type being extended;	NO
Feature Groups and Feature Group Types	p82l10	(L10) If both feature group types have zero features, then they are considered to complement each other; 	NO
Feature Groups and Feature Group Types	p82l11	(L11) Ports are pair-wise complementary if they satisfy the port connection rules specified in Section 9.2.1. This includes  appropriate port direction and matching of data component classifier references according to classifier matching rules (see Section 9.5 legality rules (L3) and (L4);	NO
Feature Groups and Feature Group Types	p82l12	(L12) Access features are pair-wise complementary if they satisfy the access connection rules in Section 9.4. 	NO
Feature Groups and Feature Group Types	p82l13	(L13) If an in or out direction is specified as part of a feature group declaration, then all features inside the feature group  must satisfy this direction. SAE AS5506B - 131 - NOTES: Aggregate data ports can be modeled in AADL V2 by a data port with a data component classifier that has data subcomponents for each of the element ports. This replaces the Aggregate_Data_Port on port groups in the original AADL standard. Standard Properties -- Port properties defined to be inherit, thus can be associated with a -- feature group to apply to all contained ports. Source_Text: inherit list of aadlstring Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Actual_Memory_Binding: inherit list of reference (memory)	NO
Ports	p83n1	(N1)  A defining port identifier must adhere to the naming rules specified for all features (see Section 8).	NO
Ports	p83n2	(N2)  The defining identifier of a port refinement declaration must also appear in a feature declaration of a component type being extended and must refer to a port or an abstract feature. SAE AS5506B - 134 -	NO
Ports	p83n3	(N3)  The unique component type identifier of the data classifier reference must be the name of a data component type. The data implementation identifier, if specified, must be the name of a data component implementation associated with the data component type.	NO
Ports	p83n4	(N4)  The prototype identifier of a prototype reference, if specified, must exist in the namespace of the component type or feature group type that contains the feature declaration. Legality Rules	NO
Ports	p83l1	(L1)  Ports can be declared in subprogram, thread, thread group, process, system, processor, virtual processor, and device component types.	NO
Ports	p83l2	(L2)  Data and event data ports may be incompletely defined by not specifying the data component classifier reference or data component implementation identifier of a data component classifier reference. The port definition can be completed using refinement.	NO
Ports	p83l3	(L3)  Data, event, and event data ports may be refined by adding a property association. The data component classifier declared as part of the data or event data port declaration being refined does not need to be included in this refinement.	NO
Ports	p83l4	(L4)  The port category of a port refinement must be the same as the category of the port being refined, or the port being refined must be an abstract feature.	NO
Ports	p83l5	(L5)  The port direction of a port refinement must be the same as the direction of the feature being refined. If the feature being refined is an abstract feature without direction, then all port directions are acceptable. Standard Properties -- Properties specifying the source text variable representing the port Source_Name: aadlstring Source_Text: inherit list of aadlstring -- property indicating whether port connections are required or optional Required_Connection : aadlboolean => true -- The protocol the source text supporting the port is assumed to make use of Allowed_Connection_Binding_Class: inherit list of classifier(processor, virtual processor, bus, virtual bus, device, memory) -- Optional property for device ports Device_Register_Address: aadlinteger -- data port connection timing Timing : enumeration (sampled, immediate, delayed) => sampled -- Input and output rate and time Input_Rate: Rate_Spec => ( Value_Range => 1.0 .. 1.0; Rate_Unit => PerDispatch; Rate_Distribution => Fixed; ) Input_Time: list of IO_Time_Spec => (( Time => Dispatch; Offset => 0.0 ns .. 0.0 ns;)) Output_Rate: Rate_Spec => ( Value_Range => 1.0 .. 1.0; Rate_Unit => PerDispatch; Rate_Distribution => Fixed; ) Output_Time: list of IO_Time_Spec => (( Time => Completion; Offset => 0.0 ns .. 0.0 ns;)) -- Port specific compute entrypoint properties for event and event data ports Compute_Entrypoint: classifier ( subprogram classifier ) SAE AS5506B - 135 - Compute_Execution_Time: Time_Range Compute_Deadline: Time -- Properties specifying binding constraints for variables representing ports Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Actual_Memory_Binding: inherit list of reference (memory) -- In port queue properties Overflow_Handling_Protocol: enumeration (DropOldest, DropNewest, Error) => DropOldest Queue_Size: aadlinteger 0 .. Max_Queue_Size => 1 Queue_Processing_Protocol: Supported_Queue_Processing_Protocols => FIFO Fan_Out_Policy: enumeration (Broadcast, RoundRobin, Selective, OnDemand) Urgency: aadlinteger 0 .. Max_Urgency Dequeued_Items: aadlinteger Dequeue_Protocol: enumeration ( OneItem, MultipleItems, AllItems ) => OneItem	NO
Subprogram and Subprogram Group Access	p84n1	(N1)  The defining identifier of a provides or requires subprogram or subprogram group access declaration must be unique within the namespace of the component type where the subcomponent access is declared.	NO
Subprogram and Subprogram Group Access	p84n2	(N2)  The defining identifier of a provides or requires subprogram or subprogram group refinement must exist as a defining identifier of a provides or requires subprogram or subprogram group or an abstract feature in the namespace of the component type being extended.	NO
Subprogram and Subprogram Group Access	p84n3	(N3)  The component type identifier or component implementation name of a subprogram or subprogram group access classifier reference, if present, must exist in the package namespace.	NO
Subprogram and Subprogram Group Access	p84n4	(N4)  The prototype identifier of a subprogram or subprogram group access classifier reference, if present, must exist in the namespace of the classifier that contains the access declaration. Legality Rules	NO
Subprogram and Subprogram Group Access	p84l1	(L1)  If a subprogram access refers to a component classifier or a component prototype, then the category of the classifier or prototype must be subprogram. SAE AS5506B - 145 -	NO
Subprogram and Subprogram Group Access	p84l2	(L2)  If a subprogram group access refers to a component classifier or a component prototype, then the category of the classifier or prototype must be subprogram group.	NO
Subprogram and Subprogram Group Access	p84l3	(L3)  An abstract feature can be refined into a subprogram access or a subprogram group access. In this case, the abstract feature must not have a direction specified.	NO
Subprogram and Subprogram Group Access	p84l4	(L4)  A subprogram or subprogram group access declaration that does not specify a component classifier reference is incomplete. Such a reference can be added in a subprogram or subprogram group access refinement declaration.	NO
Subprogram and Subprogram Group Access	p84l5	(L5)  A subprogram or subprogram group access declaration may be refined by adding a property association. Inclusion of the component classifier reference is optional.	NO
Subprogram and Subprogram Group Access	p84l6	(L6)  A provides subprogram access cannot be refined to a requires subprogram access and a requires subprogram access cannot be refined to a provides subprogram access. Similarly, a provides subprogram group access cannot be refined to a requires subprogram group access and a requires subprogram group access cannot be refined to a provides subprogram group access. Consistency Rules	NO
Subprogram and Subprogram Group Access	p84c1	(C1) A provides subprogram access feature indicates that a subprogram is made available to be referenced. A project  may enforce a consistency rule that a subprogram access connection connects this feature to directly a subprogram subcomponent, or indirectly via a requires subprogram (group) access or provides subprogram (group) access. Standard Properties -- Subprogram call rate for subprogram access Subprogram_Call_Rate: Rate_Spec => ( Value_Range => 1.0 .. 1.0; Rate_Unit => PerDispatch; Rate_Distribution => Fixed; ) Queue_Size: aadlinteger 0 .. Max_Queue_Size => 1 Queue_Processing_Protocol: Supported_Queue_Processing_Protocols => FIFO Overflow_Handling_Protocol: enumeration (DropOldest, DropNewest, Error) => DropOldest Urgency: aadlinteger 0 .. Max_Urgency	NO
Subprogram Parameters	p85n1	(N1)  The defining identifier of a parameter must be unique within the namespace of the subprogram type containing the parameter declaration.	NO
Subprogram Parameters	p85n2	(N2)  The defining parameter identifier of a parameter refinement declaration must also appear in a feature declaration of a component type being extended and must refer to a parameter or an abstract feature.	NO
Subprogram Parameters	p85n3	(N3)  The data classifier reference must refer to a data component type or a data component implementation.	NO
Subprogram Parameters	p85n4	(N4)  The prototype identifier, if present, must exist in the namespace of the subprogram classifier that contains the parameter declaration. Legality Rules	NO
Subprogram Parameters	p85l1	(L1)  Parameters can be declared for subprogram component types.	NO
Subprogram Parameters	p85l2	(L2)  A parameter declaration that does not specify a data classifier reference is incomplete. Such a reference can be added in a parameter refinement declaration.	NO
Subprogram Parameters	p85l3	(L3)  A parameter declaration may be refined by adding a property association. Inclusion of the data classifier reference is optional.	NO
Subprogram Parameters	p85l4	(L4)  The parameter direction of a parameter refinement must be the same as the direction of the feature being refined. If the feature being refined is an abstract feature without direction, then all parameter directions are acceptable. SAE AS5506B - 150 - Standard Properties -- Properties specifying the source text representation of the parameter Source_Name: aadlstring Source_Text: inherit list of aadlstring	NO
Data Component Access	p86n1	(N1)  The defining identifier of a provides or requires data access declaration must be unique within the namespace of the component type where the data access is declared.	NO
Data Component Access	p86n2	(N2)  The defining identifier of a provides or requires data access refinement must exist as a defining identifier of a provides or requires data access or as a defining identifier of an abstract feature in the namespace of the component type being extended.	NO
Data Component Access	p86n3	(N3)  The component type identifier or component implementation name of a data access classifier reference must exist in the package namespace.	NO
Data Component Access	p86n4	(N4)  The prototype identifier, if present, must exist in the namespace of the classifier that contains the data access declaration. Legality Rules	NO
Data Component Access	p86l1	(L1)  If a data access refers to a component classifier or a component prototype, then the category of the classifier or prototype must be of category data.	NO
Data Component Access	p86l2	(L2)  A data access declaration may be refined by refining the data classifier, by adding a property association, or by doing both. If the refinement only adds a property association the classifier reference is optional.	NO
Data Component Access	p86l3	(L3)  A provides data access cannot be refined to a requires data access and a requires data access cannot be refined to a provides data access.	NO
Data Component Access	p86l4	(L4)  An abstract feature can be refined into a data access. In this case, the abstract feature must not have a direction specified. Consistency Rules	NO
Data Component Access	p86c1	(C1) A data access declaration that does not specify a data classifier reference is incomplete. Such a reference can be  added in a data access refinement declaration.	NO
Data Component Access	p86c2	(C2) If the source code of a component does access shared data, then the component type declaration must specify a  requires data access declaration. In other words, for all components that access shared data their component type declaration must reflect that fact.	NO
Data Component Access	p86c3	(C3) A data access refinement may refine an abstract feature declaration. If the abstract feature declaration specifies a  direction of in, then the access right of the data access must be read-only. If the direction is out, then the access right of the data access must be write-only. If the abstract feature does not have a specified direction, then any access right is acceptable. Standard Properties Access_Right : Access_Rights => read_write -- access time range for data access Access_Time: record ( First: IO_Time_Spec ; Last: IO_Time_Spec ; ) => ( First =>(Time => Start; Offset => 0.0 ns .. 0.0 ns;); Last => (Time => Completion; Offset => 0.0 ns .. 0.0 ns;); ) SAE AS5506B - 152 -	NO
Bus Component Access	p87n1	(N1)  The defining identifier of a provides or requires bus access declaration must be unique within the namespace of the component type where the bus access is declared.	NO
Bus Component Access	p87n2	(N2)  The defining identifier of a provides or requires bus refinement must exist as a defining identifier of a requires or provides bus access or of an abstract feature in the namespace of the component type being extended.	NO
Bus Component Access	p87n3	(N3)  The component type identifier or component implementation name of a bus access classifier reference must exist in the package namespace.	NO
Bus Component Access	p87n4	(N4)  The prototype identifier, if present, must exist in the namespace of the classifier that contains the bus access declaration. Legality Rules	NO
Bus Component Access	p87l1	(L1)  If a bus access refers to a component classifier or a component prototype, then the category of the classifier or prototype must be of category bus.	NO
Bus Component Access	p87l2	(L2)  A bus access declaration may be refined by refining the bus classifier, by adding a property association, or by doing both. If the refinement only adds a property association the bus classifier reference is optional.	NO
Bus Component Access	p87l3	(L3)  A provides bus access cannot be refined to a requires bus access and a requires bus access cannot be refined to a provides bus access.	NO
Bus Component Access	p87l4	(L4)  An abstract feature can be refined into a bus access. In this case, the abstract feature must not have a direction specified. Consistency Rules	NO
Bus Component Access	p87c1	(C1) A bus access declaration that does not specify a bus classifier reference is incomplete. Such a reference can be  added in a bus access refinement declaration.	NO
Bus Component Access	p87c2	(C2) If a bus access feature is a refinement of an abstract feature, then the direction of the abstract feature, if specified,  imposes a restriction on the access right, i.e., in implies read-only, and out implies write-only. Standard Properties Access_Right : Access_Rights => read_write SAE AS5506B - 155 -	NO
Bus Component Access	p87n1	(N1)  The defining identifier of a defined connection declaration must be unique in the local namespace of the component implementation with the connection subclause. This is also the case for mode-specific connection declarations, i.e., declarations with an in_modes_and_transition subclause.	NO
Bus Component Access	p87n2	(N2)  The connection identifier in a connection refinement declaration must refer to a named connection declared in an ancestor component implementation. Legality Rules	NO
Bus Component Access	p87l1	(L1)  A connection refinement must contain at least one of the following: a connection source and destination subclause, a property association, an in modes subclause.	NO
Bus Component Access	p87l2	(L2)  If a semantic connection may be active in a particular mode, then the ultimate source and ultimate destination components must be part of that mode.	NO
Bus Component Access	p87l3	(L3)  If a semantic connection may be active in a particular mode transition, then the ultimate source component must be part of a system mode that includes the old mode identifier and the ultimate destination component must be part of a system mode that includes the new mode identifier.	NO
Feature Connections	p91n1	(N1)  A source or destination reference in a feature connection or feature connection refinement declaration must reference a feature declared in the component type, a feature in a feature group of the component type, or a feature of one of the subcomponents. The source and destination features must be abstract features, ports, parameters, or access features.	NO
Feature Connections	p91n2	(N2)  The subcomponent reference may refer to a subcomponent or a subcomponent array. Legality Rules The direction declared for the destination feature of a feature connection declaration must be compatible with the direction declared for the source feature as defined by the following rules:	NO
Feature Connections	p91l1	(L1)  If the feature connection declaration represents a connection between features of sibling components, then the source must be an outgoing feature and the destination must be an incoming feature. An outgoing feature is an abstract feature with no direction or out direction, an outgoing port or parameter with an out or in out direction, or an access feature, in the case of data access with at least write access. An incoming feature is an abstract feature with no direction or in direction, an incoming port or parameter with an in or in out direction, or an access feature, in the case of data access with at least read access.	NO
Feature Connections	p91l2	(L2)  If the feature connection declaration represents a connection between features up the containment hierarchy, then the source and destination must both be outgoing features.	NO
Feature Connections	p91l3	(L3)  If the feature connection declaration represents a connection between features down the containment hierarchy, then the source and destination must both be incoming features.	NO
Feature Connections	p91l4	(L4)  If the feature connection declaration specifies a directional connection, then the direction of the connection must be supported by the direction of the source and destination features.	NO
Feature Connections	p91l5	(L5)  The individual connections of a semantic connection must be bidirectional or have the same direction. The direction of the connection is determined by the direction of the source and destination feature and by the direction of the connection declarations. Standard Properties Required_Virtual_Bus_Class : inherit list of classifier (virtual bus) Required_Connection_Quality_Of_Service : inherit list of Supported_Connection_QoS Connection_Pattern: list of Supported_Connection_Patterns SAE AS5506B - 159 - Connection_Set: list of Connection_Pair	NO
Port Connections	p92n1	(N1)  The connection identifier in a port connection refinement declaration must refer to a named port or feature connection declared in an ancestor component implementation.	NO
Port Connections	p92n2	(N2)  A source or destination reference in a port connection or port connection refinement declaration must reference a port declared in the component type, a port of one of the subcomponents, or a port that is an element of a feature group in the component type, or it must refer to a requires data access in the component type, a provides data access in one of the subcomponents, or a data subcomponent.	NO
Port Connections	p92n3	(N3)  The subcomponent reference may also consist of a reference to a subcomponent array.	NO
Port Connections	p92n4	(N4)  The event_or_event_data identifier of event source specifications (self.event_or_event_data_identifier) must not conflict with defining identifiers in the namespace of the component that contains the connection referencing the event source. Legality Rules	NO
Port Connections	p92l1	(L1)  In the case of a directional port connection the connection end representing the source of the flow must be the source of the connection and the connection end representing the destination of the flow must be the destination of the connection.	NO
Port Connections	p92l2	(L2)  In the case of a bidirectional port connection either connection end can be the source. If the bidirectional connection has directional connection ends, then the flow is determined by the direction of the connection ends. In the case of ports it is the port direction and in the case of data access features it is the access right.	NO
Port Connections	p92l3	(L3)  If the source connection end is a data access feature it must have read access rights; if the destination connection end is a data access feature it must have write access rights.	NO
Port Connections	p92l4	(L4)  The feature identifier of a subcomponent reference may refer to a feature array, if the subcomponent is a thread, device, or processor.	NO
Port Connections	p92l5	(L5)  The following are acceptable sources and destinations of port connections. The left column shows connections between ports, while the right column shows connection between ports and data components. event port -> event port data port -> data port, event data port, event port event data port -> event data port, data port, event port data, data access -> data port, event data port, event port data port, event data port -> data, data access SAE AS5506B - 162 - The direction of the source port of a port connection declaration must be compatible with the direction of the destination port as defined by the following rules:	NO
Port Connections	p92l6	(L6)  If the port connection declaration represents a connection between ports of sibling components, then the source must be an outgoing port and the destination must be an incoming port. If the source connection end is a data access feature, then it must be a provides access feature; if it is a destination connection end it must be a requires access feature.	NO
Port Connections	p92l7	(L7)  If the port connection declaration represents a connection between ports up the containment hierarchy, then the source and destination must both be outgoing ports. If the source connection end is a data access feature, then it must be a provides access feature; if it is a destination connection end it must be a requires access feature.	NO
Port Connections	p92l8	(L8)  If the port connection declaration represents a connection between ports down the containment hierarchy, then the source and destination must both be incoming ports. If the source connection end is a data access feature, then it must be a requires access feature; if it is a destination connection end it must be a provides access feature.	NO
Port Connections	p92l9	(L9)  The individual connections of a semantic port connection must be bidirectional or have the same direction. The direction of the connection is determined by the direction of the source and destination feature and by the direction of the connection declarations.	NO
Port Connections	p92l10	(L10) Self.<identifier> must only be referenced as the source of a connection. 	NO
Port Connections	p92l11	(L11) A data port cannot be the destination of more than one semantic port connection unless each semantic port  connection is contained in a different mode.	NO
Port Connections	p92l12	(L12) A semantic connection cannot contain connection declarations with both immediate and delayed Timing property  values.	NO
Port Connections	p92l13	(L13) For connections between data ports, event data ports and data access, the data classifier of the source port must  match the data type of the destination port. The Classifier_Matching_Rule property specifies the rule to be applied to match the data classifier of a connection source to the data classifier of a connection destination.	NO
Port Connections	p92l14	(L14) The following rules are supported:  • • • • Classifier_Match: The source data type and data implementation must be identical to the data type or data implementation of the destination. If the destination classifier is a component type, then any implementation of the source matches. This is the default rule. Equivalence: An indication that the two classifiers of a connection are considered to match if they are listed in the Supported_Classifier_Equivalence_Matches property. Acceptable data classifier matches are specified as Supported_Classifier_Equivalence_Matches property with pairs of classifier values representing acceptable matches. Either element of the pair can be the source or destination classifier. Equivalence is intended to be used when the data types are considered to be identical, i.e., no conversion is necessary. The Supported_Classifier_Equivalence_Matches property is declared globally as a property constant. Subset: A mapping of (a subset of) data elements of the source port data type to all data elements of the destination port data type. Acceptable data classifier matches are specified Supported_Classifier_Subset_Matches property with pairs of classifier values representing acceptable matches. The first element of each pair specifies the acceptable source classifier, while the second element specifies the acceptable destination classifier. The Supported_Classifier_Subset_Matches property is declared globally as a property constant. A virtual bus or bus must represent a protocol that supports subsetting, such as OMG DDS. Conversion: A mapping of the source port data type to the destination port data type, where the source port data type requires a conversion to the destination port data type. Acceptable data classifier matches are specified as Supported_Type_Conversions property with pairs of classifier values representing acceptable matches. The first element of each pair specifies the acceptable source classifier, while the second element specifies the acceptable destination classifier. The Supported_Type_Conversions property may be declared globally as a property constant. A virtual bus or bus must support the conversion from the source data classifier to the destination classifier. SAE AS5506B - 163 -	NO
Port Connections	p92l15	(L15) If more than one port connection declaration in a semantic port connection has a property association for a given  connection property, then the resulting property values must be identical.	NO
Port Connections	p92l16	(L16) A processor port specification must only be used in event connections within threads and subprograms.  Consistency Rules	NO
Port Connections	p92c1	(C1) There cannot be cycles of immediate connections between threads, devices, and processors. 	NO
Port Connections	p92c2	(C2) The processor port identifier of a processor port specification (processor.processor_port_identifier) must name a  port of the processor that the thread is bound to.	NO
Port Connections	p92c3	(C3) The Supports_Classifier_Subset_Matches property may be associated with a bus or virtual bus. This  specifies the subset matches a particular protocol supports. Subset matches of connections bound to such a virtual bus or bus must be supported by the respective virtual bus or bus.	NO
Port Connections	p92c4	(C4) The Supports_Type_Conversions property may be associated with a bus or virtual bus. This specifies the  subset matches a particular protocol supports. Subset matches of connections bound to such a virtual bus or bus must be supported by the respective virtual bus or bus. Standard Properties Timing : enumeration (sampled, immediate, delayed) => sampled Connection_Pattern: list of Supported_Connection_Patterns Connection_Set: list of Connection_Pair Transmission_Type: enumeration ( push, pull ) Required_Connection_Quality_Of_Service : inherit list of Supported_Connection_QoS Allowed_Connection_Binding_Class: inherit list of classifier(processor, virtual processor, bus, virtual bus, device, memory) Allowed_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) Not_Collocated: record ( Targets: list of reference (data, thread, process, system, connection); Location: classifier ( processor, memory, bus, system ); ) Actual_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory)	NO
Parameter Connections	p93n1	(N1)  The connection identifier in a parameter connection refinement declaration must refer to a named parameter or feature connection declared in an ancestor component implementation.	NO
Parameter Connections	p93n2	(N2)  A source (destination) reference in a parameter connection declaration must reference a parameter of a preceding (succeeding) subprogram call, a parameter declared in the component type of the containing subprogram, a data port or event data port declared in the component type of the enclosing thread, a data port or event data port that is an element of a feature group in the component type of the enclosing thread, a data subcomponent, or a requires data access to a data component. Legality Rules	NO
Parameter Connections	p93l1	(L1)  The source of a parameter connection must be an incoming data or event data port of the containing thread, an incoming parameter of the containing subprogram, or a data subcomponent or requires data access with read-only or read-write access rights, or an outgoing parameter of a previous subprogram call.	NO
Parameter Connections	p93l2	(L2)  The following source/destination pairs are acceptable for parameter connection declarations: threadport -> call.parameter requiresdataaccess -> call.parameter threadfeaturegroup.port -> call.parameter featuregroup.requiresdataaccess -> call.parameter SAE AS5506B call.parameter -> threadport call.parameter -> requiresdataaccess call.parameter -> threadfeaturegroup.port call.parameter -> featuregroup.requiresdataaccess call.parameter -> threadincompletefeaturegroup call.parameter -> datasubcomponent containedcall.parameter -> parameter datasubcomponent -> call.parameter parameter -> containedcall.parameter call.parameter -> call.parameter - 173 -	NO
Parameter Connections	p93l3	(L3)  A parameter cannot be the destination feature reference of more than one parameter connection declaration unless the source feature reference of each parameter connection declaration is contained in a different mode. In this case, the restriction applies for each mode.	NO
Parameter Connections	p93l4	(L4)  The data classifier of the source and destination must match. The matching rules as specified by the Classifier_Matching_Rule property apply (see Section 9.2 (L13)). By default the data classifiers must be match.	NO
Access Connections	p94n1	(N1)  The connection identifier in an access connection refinement declaration must refer to a named access or feature connection declared in an ancestor component implementation.	NO
Access Connections	p94n2	(N2)  An access reference in an access connection declaration must reference an access feature of a subcomponent, subprogram call, or processor, an access feature in the component type of the containing component, an access feature in a feature group of the containing component type, or a data, bus, subprogram, or subprogram group subcomponent. Legality Rules	NO
Access Connections	p94l1	(L1)  The category of the source and the destination of a access connection declaration must be the same, i.e., they must both be data, bus, subprogram, or subprogram group, or their respective access feature.	NO
Access Connections	p94l2	(L2)  In the case of a bidirectional semantic access connection either connection end can be the source.	NO
Access Connections	p94l3	(L3)  In the case of a directional data or bus access connection the connection end representing the component being accessed must be the source for read access, and the destination for write access, i.e., the direction declared for the access connection must be compatible with the direction of the data flow for reading or writing based on the access rights.	NO
Access Connections	p94l4	(L4)  In a partial AADL model the ultimate source or destination may be a provides access feature of a component instead of the subcomponent. The provides and requires indicators of source and destination access features must satisfy the following rules:	NO
Access Connections	p94l5	(L5)  If the access connection declaration represents an access connection between access features of sibling components, then the source must be a provides access, and the destination must be a requires access.	NO
Access Connections	p94l6	(L6)  If the access connection declaration represents a feature mapping up the containment hierarchy, then one connection end must be a provides access of a subcomponent, or a data, subprogram, or bus subcomponent; and the other connection end must be a provides access feature of the enclosing component or a provides feature of a feature group of the enclosing component.	NO
Access Connections	p94l7	(L7)  If the access connection declaration represents a feature mapping down the containment hierarchy, then one connection end must be a requires access of the enclosing component, a requires access of a feature group of the enclosing component, or a data, subprogram, or bus subcomponent; and the other connection end must be a requires access of a subcomponent.	NO
Access Connections	p94l8	(L8)  A requires access cannot be the source or destination feature reference of more than one access connection declaration unless the source feature reference(s) of each access connection declaration is (are) contained in a different mode. In this case, the restriction applies for each mode.	NO
Access Connections	p94l9	(L9)  For access connections the classifier of the provider access must match to the classifier of the requires access according to the Classifier_Matching_Rules property. By default the classifiers must be the same (see Section 9.1). SAE AS5506B - 176 -	NO
Access Connections	p94l10	(L10) If more than one access feature in a semantic access connection has an Access_Right property association,  then the resulting property values must be compatible. This means that the provider must provide read-only or read-write access if the requirer specifies read-only. Similarly, the provider must provide write-only or read-write access if the requirer specifies write-only. The provider must provide read-write access if the requirer specifies read-write. Finally, the provider must provide by-method access if the requirer specifies bymethod access.	NO
Access Connections	p94l11	(L11) The category of the access connection source and destination must be identical. If the component category is  specified as part of the connection declaration, then it must be identical to that of the source and destination. Bus, data, subprogram, and subprogram group are acceptable categories. Standard Properties Connection_Pattern: list of Supported_Connection_Patterns Connection_Set: list of Connection_Pair	NO
Feature Group Connections	p95n1	(N1)  The connection identifier in a feature group connection refinement declaration must refer to a feature group named connection declared in an ancestor component implementation.	NO
Feature Group Connections	p95n2	(N2)  A source or destination reference in a feature group connection declaration must reference a feature group declared in the component type, a feature group of one of the subcomponents, or feature group that is an element of a feature group in the component type. The subcomponent reference may also consist of a reference on a subcomponent array. Legality Rules	NO
Feature Group Connections	p95l1	(L1)  If the feature group connection declaration represents a component connection between sibling components, the feature group types must be complements. This may be indicated by both feature group declarations referring to the same feature group type and one feature group declared as inverse of, by the feature group type of one feature group being declared as the inverse of the feature group type of the other feature group, or by the two referenced feature group types meeting the complement requirements as defined in Section 8.2.	NO
Feature Group Connections	p95l2	(L2)  The Classifier_Matching_Rule property specifies the rule to be applied to match the feature group classifier of a connection source to that of a connection destination.	NO
Feature Group Connections	p95l3	(L3)  The following rules are supported for feature group connection declarations that represent a connection up or down the containment hierarchy: • • • Classifier_Match: The source feature group type must be identical to the feature group type of the destination. This is the default rule. Equivalence: An indication that the two classifiers of a connection are considered to match if they are listed in the Supported_Classifier_Equivalence_Matches property. Matching feature group types are specified by the Supported_Classifier_Equivalence_Matches property with pairs of classifier values representing acceptable matches. Either element of the pair can be the source or destination classifier. Equivalence is intended to be used when the feature group types are considered to be identical, i.e., their elements match. The Supported_Classifier_Equivalence_Matches property is declared globally as a property constant. Subset: An indication that the two classifiers of a connection are considered to match if the outer feature group has outcoming features that are a subset of outgoing features of the inner feature group, and if the inner feature group has incoming features that are a subset of incoming features of the outer feature group. The pairs of features are expected to have the same name. SAE	NO
Feature Group Connections	p95l4	(L4)  AS5506B - 178 - The following rules are supported for feature group connection declarations that represent a connection between two subcomponents, i.e., sibling component: • • • Classifier_Match: The source feature group type must be the complement of the feature group type of the destination. This is the default rule. Complement: An indication that the two classifiers of a connection are considered to complement if they are listed in the Supported_Classifier_Complement_Matches property. Matching feature group types are specified by the Supported_Classifier_Complement_Matches property with pairs of classifier values representing acceptable matches. Either element of the pair can be the source or destination classifier. Complement is intended to be used when the feature group types are considered to be identical, i.e., their elements match. The Supported_Classifier_Complement_Matches property is declared globally as a property constant. Subset: An indication that the two classifiers of a connection are considered to match if each has incoming features that are a subset of outgoing features of the other. The pairs of features are expected to have the same name. A feature group may have a direction declared; otherwise it is considered bidirectional. The direction declared for the destination feature group of a feature group connection declaration must be compatible with the direction declared for the source feature group as defined by the following rules:	NO
Feature Group Connections	p95l5	(L5)  If the feature group connection declaration represents a connection between feature group of sibling components, then the source must be an outgoing feature group and the destination must be an incoming feature group.	NO
Feature Group Connections	p95l6	(L6)  If the feature group connection declaration represents a connection between feature groups up the containment hierarchy, then the source and destination must both be an outgoing feature group.	NO
Feature Group Connections	p95l7	(L7)  If the feature group connection declaration represents a connection between feature groups down the containment hierarchy, then the source and destination must both be an incoming feature group.	NO
Feature Group Connections	p95l8	(L8)  A feature group connection must be bidirectional or be consistent with the direction of the source and destination feature. Standard Properties Connection_Pattern: list of Supported_Connection_Patterns Connection_Set: list of Connection_Pair Transmission_Type: enumeration ( push, pull ) Allowed_Connection_Binding_Class: inherit list of classifier(processor, virtual processor, bus, virtual bus, device, memory) Allowed_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) Not_Collocated: record ( Targets: list of reference (data, thread, process, system, connection); Location: classifier ( processor, memory, bus, system ); ) Actual_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory)	NO
	p101 Flow Specificationsn1	(N1)  The defining flow identifier of a flow specification must be unique within the interface name space of the component type.	NO
	p101 Flow Specificationsn2	(N2)  The flow feature identifier in a flow path must refer to a port, parameter, data access feature, or feature group in the component type, or to a port, data access feature, or feature group contained in a feature group in the component type.	NO
	p101 Flow Specificationsn3	(N3)  The defining flow identifier of a flow specification refinement must refer to a flow specification or refinement in an ancestor component type. Legality Rules	NO
	p101 Flow Specificationsl1	(L1)  The direction declared for the out_flow of a flow path specification declaration must be compatible with the direction declared for the in_flow as defined by the following rules:	NO
	p101 Flow Specificationsl2	(L2)  If the in_flow is a port or parameter, its direction must be must be an in or an in out.	NO
	p101 Flow Specificationsl3	(L3)  If the out_flow is a port or parameter, its direction must be an out or an in out.	NO
	p101 Flow Specificationsl4	(L4)  If the in_flow is a data access, its access right must be must be Read_Only or Read_Write. SAE AS5506B - 185 -	NO
	p101 Flow Specificationsl5	(L5)  If the out_flow is a data access, its direction must be Write_Only or Read_Write.	NO
	p101 Flow Specificationsl6	(L6)  If the in_flow is a feature group then it must contain at least one port or data access that satisfies the above rule, or it must have an empty set of ports.	NO
	p101 Flow Specificationsl7	(L7)  If the out_flow is a feature group then it must contain at least one port or data access that satisfies the above rule, or it must have an empty set of ports.	NO
	p101 Flow Specificationsl8	(L8)  The direction declared for the out flow of a flow source specification declaration must be the same as for out flows in flow paths.	NO
	p101 Flow Specificationsl9	(L9)  The direction declared for the in_flow of a flow sink specification declaration must be the same as for in_flow of flow paths.	NO
	p101 Flow Specificationsl10	(L10) If the flow specification refers to a feature group then the feature group must contain at least one port, data access,  or parameter that satisfies the above rules, or the feature group must have an empty list of features. Standard Properties Latency: Time_Range NOTES: These properties are examples of properties for latency and throughput analysis. Additional properties are also necessary on ports to fully support throughput analysis, such as arrival rate and data size. Appropriate properties for flow analysis may be defined by the tool vendor or user (see Section 11).	NO
	p102 Flow Implementationsn1	(N1)  The flow identifier of a flow implementation must name a flow specification in the component type. A flow implementation name may appear more than once in each component implementation, either as alternative flows under different modes or transitions (using in modes), or to represent multiple flows for the same flow specification such as replicated flows to support redundancy or different flows for different elements of feature groups.	NO
	p102 Flow Implementationsn2	(N2)  The in_flow and out_flow feature identifier in a flow implementation must refer to the same in_flow and out_flow feature as the flow specification it implements.	NO
	p102 Flow Implementationsn3	(N3)  The subcomponent flow identifier of a flow implementation must name a subcomponent and optionally a flow specification in the component type of the named subcomponent, or it must name a data component in the form of a data subcomponent, provides data access, or requires data access.	NO
	p102 Flow Implementationsn4	(N4)  In case of a flow source implementation the flow identifier of the first subcomponent must refer to a flow source or a data component.	NO
	p102 Flow Implementationsn5	(N5)  In case of a flow sink implementation the flow identifier of the last subcomponent must refer to a flow sink or a data component.	NO
	p102 Flow Implementationsn6	(N6)  In all other cases the subcomponent flow identifier must refer to a flow path or a data component.	NO
	p102 Flow Implementationsn7	(N7)  The connection identifier in a flow implementation must refer to a connection in the component implementation. Legality Rules	NO
	p102 Flow Implementationsl1	(L1)  The source of a connection named in a flow implementation declaration must be the same as the in_flow feature of the flow implementation, or as the out flow feature of the directly preceding subcomponent flow specification, if present.	NO
	p102 Flow Implementationsl2	(L2)  The destination of a connection named in a flow implementation declaration must be the same as the out flow feature of the flow implementation, or as the in_flow feature of the directly succeeding subcomponent flow specification, if present. SAE AS5506B - 189 -	NO
	p102 Flow Implementationsl3	(L3)  The in_flow feature of a flow implementation must be identical to the in_flow feature of the corresponding flow specification. The out_flow feature of a flow implementation must be identical to the out_flow feature of the corresponding flow specification.	NO
	p102 Flow Implementationsl4	(L4)  If the component implementation provides mode-specific flow implementations, as indicated by the in modes statement, then the set of modes in the in modes statement of all flow implementations for a given flow specification must include all the modes for which the flow specification is declared.	NO
	p102 Flow Implementationsl5	(L5)  In case of a mode-specific flow implementation, the connections and the subcomponents named in the flow implementation must be declared at least for the modes listed in the in modes statement of the flow implementation.	NO
	p102 Flow Implementationsl6	(L6)  Flow implementations may be declared from an in_flow feature directly to an out_flow feature.	NO
	p102 Flow Implementationsl7	(L7)  Component type extensions may refine flow specifications and component implementation extensions may refine subcomponents and connections with in modes statements. A flow implementation that is inherited by the extension must be consistent with the modes of the refined flow specifications, subcomponents, and connections if named in the flow implementation according to rules (L4) and (L5). Otherwise, the flow implementation has to be defined again in the component implementation extension and satisfy rules (L4) and (L5).	NO
	p102 Flow Implementationsl8	(L8)  Component implementation extensions may declare flow implementations for flow specifications that were already declared in the component implementation being extended. Consistency Rules	NO
	p102 Flow Implementationsc1	(C1) If the component implementation has subcomponents, then a flow implementation declaration is required for each  flow specification for a fully refined flow.	NO
	p103 End-To-End Flowsn1	(N1)  The defining end-to-end flow identifier of an end-to-end flow declaration must be unique within the local name space of the component implementation containing the end-to-end flow declaration.	NO
	p103 End-To-End Flowsn2	(N2)  The connection identifier in an end-to-end flow declaration must refer to a connection in the component implementation.	NO
	p103 End-To-End Flowsn3	(N3)  The subcomponent flow identifier of an end-to-end flow declaration must name an optional flow specification in the component type of the named subcomponent or to a data component in the form of a data subcomponent, provides data access, or requires data access.	NO
	p103 End-To-End Flowsn4	(N4)  The end-to-end flow identifier referenced in an end-to-end flow declaration must name an end-to-end flow in the name space of the same component implementation.	NO
	p103 End-To-End Flowsn5	(N5)  The defining identifier of an end-to-end flow refinement must refer to an end-to-end flow or refinement in an ancestor component implementation. Legality Rules	NO
	p103 End-To-End Flowsl1	(L1)  The flow specifications identified by the flow_path_subcomponent_flow_identifier must be flow paths, if present.	NO
	p103 End-To-End Flowsl2	(L2)  The start_subcomponent_flow_identifier must refer to a flow path or a flow source, or to a data component.	NO
	p103 End-To-End Flowsl3	(L3)  The end_subcomponent_flow_identifier must refer to a flow path or a flow sink, or to a data component.	NO
	p103 End-To-End Flowsl4	(L4)  If an end-to-end flow is referenced in an end-to-end flow declaration, then its first and last subcomponent flow must name the same port as the preceding or succeeding connection. SAE	NO
	p103 End-To-End Flowsl5	(L5)  AS5506B - 192 - In case of a mode specific end-to-end flow declarations, the named connections and the subcomponents of the named flow specifications must be declared for the modes listed in the in modes statement. Standard Properties Actual_Latency: Time_Range NOTES: These properties are examples of properties for latency and throughput analysis. The expected property values represent constraints that must be satisfied by the actual property values of the end-to-end flow. The semantics of the constraint are analysis specific.	NO
	p111 Property Setsn1	(N1)  Property set defining identifiers must be unique in the global namespace.	NO
	p111 Property Setsn2	(N2)  The defining identifier following the reserved word end must be identical to the defining identifier following the reserved word property set.	NO
	p111 Property Setsn3	(N3)  Associated with every property set is a property set namespace that contains the defining identifiers for all property types, property definitions, and property constants declared within that property set. This means that property types, properties, and property constants with the same identifier can be declared in different property sets.	NO
	p111 Property Setsn4	(N4)  A property, property constant, or property type declared in a property set is always named by its qualified name that is the property set identifier followed by the property identifier, separated by a double colon (“::”). This qualification is necessary even for references to properties, property constants, and property types in the same property set due to the fact that predeclared properties do not have to be qualified. Predeclared properties and property types may be referred to by their property identifiers without a property set qualifier. SAE AS5506B - 195 -	NO
	p111 Property Setsn5	(N5)  The property set identifiers and package names listed in an import_declaration must exist in the global namespace.	NO
	p111 Property Setsn6	(N6)  The property set identifier of a qualified property name must be listed in an import_declaration of the property set or package unless it is the name of the property set that contains the qualified name.	NO
	p111.1 Property Typesn1	(N1)  All property type defining identifiers declared within the same property set must be distinct from each other, i.e., unique within the property set namespace.	NO
	p111.1 Property Typesn2	(N2)  A property type is named by its property type identifier or the qualified name specified by the property set/property type identifier pair, separated by a double colon (“::”). An unqualified property type identifier must be part of the predeclared property sets.	NO
	p111.1 Property Typesn3	(N3)  An enumeration type introduces an enumeration namespace. The enumeration literal identifiers in the enumeration list declare an ordered list of enumeration literals. They must be unique within this namespace.	NO
	p111.1 Property Typesn4	(N4)  A units type introduces a units namespace. The units identifiers in the units list declare a set of units literals. They must be unique within this namespace. SAE AS5506B - 198 -	NO
	p111.1 Property Typesn5	(N5)  The units identifier to the right of a => in a units literal statement must refer to a unit identifier defined earlier in the sequence of the same units type declaration.	NO
	p111.1 Property Typesn6	(N6)  The classifier meta model identifier must refer to a class in the AADL meta model or an Annex meta model. In the case of an Annex meta model, the identifier is qualified by the annex name. Acceptable classes are listed in tabular form in Appendix C.3 and in relevant Annex standards.	NO
	p111.1 Property Typesn7	(N7)  The named element meta model identifier must refer to a class in the AADL meta model or an Annex meta model that is a subclass of the NamedElement class and a structural feature, in the case of the AADL core language a subclass of the ClassifierFeature class. In the case of an Annex meta model, the identifier is qualified by the annex name. Acceptable classes are listed in tabular form in an appendix of this standard and in relevant Annex standards.	NO
	p111.1 Property Typesn8	(N8)  The identifiers of the property field declarations in a record property type must be unique within the record declaration, i.e., the record type represents a local namespace for record field identifiers. Legality Rules	NO
	p111.1 Property Typesl1	(L1)  The value of the first numeric literal that appears in a range of a number_type must not be greater than the value of the second numeric literal including the value’s units.	NO
	p111.1 Property Typesl2	(L2)  Range values must always be declared with unit literals if the property requires a unit literal.	NO
	p111.1 Property Typesl3	(L3)  The unique property constant identifier in an integer range must represent an integer constant. If the integer type requires units, then the constant value must include a unit literal of the specified units type.	NO
	p111.1 Property Typesl4	(L4)  A boundless range type may be declared such that the actual range declarations have no limit on the upper and lower bound.	NO
	p111.1 Property Typesl5	(L5)  The unique property constant identifier in a real range must represent a real constant. If the real type requires units, then the constant value must include a unit literal of the specified units type.	NO
	p111.1 Property Typesl6	(L6)  If the property requires a unit, then the unit must be specified for both lower and upper bound and the unit literal must be of the specified units type..	NO
	p111.1 Property Typesl7	(L7)  If a range is specified for aadlinteger or aadlreal then the actual value assigned to a property of this type must be within the specified range. NOTES: In the original AADL standard reserved words were used to identify the classifier category or reference category. Those names are compatible with the qualified meta model identifiers of AADL V2 with the exception of connections. It is now named connection.	NO
	p111.2n1	(N1)  All defining identifiers of property definitions declared within the same property set must be distinct from each other and distinct from all property type defining identifiers declared within that property set. The property set namespace contains the defining identifiers for all property definitions declared within that property set.	NO
	p111.2n2	(N2)  A property is named by its property definition identifier or the qualified name specified by the property set/property definition identifier pair, separated by a double colon (“::”). An unqualified property identifier must be part of the predeclared property sets.	NO
	p111.2n3	(N3)  The named_element_meta_model_identifier must identify the name of a class in the AADL meta model or an Annex meta model that is a subclass of the AADL meta model class NamedElement. In case of an Annex meta model, the identifier is qualified by the annex name. Acceptable classes are listed in tabular form in an appendix of this standard and in relevant Annex standards.	NO
	p111.2n4	(N4)  The unique_classifier_reference must identify the name of a classifier in the public section of the named package. Legality Rules	NO
	p111.2l1	(L1)  All properties are automatically defined for components of the category abstract, i.e., the category abstract is implicitly included in all applies to statements. SAE	NO
	p111.2l2	(L2)  AS5506B - 201 - Classifier and reference property definition must not have a default value.	NO
	p111.3 Property Constantsn1	(N1)  The defining property constant identifier must be distinct from all other property constant identifiers, property definition identifiers, and property type identifiers in the namespace of the property set that contains the property constant declaration.	NO
	p111.3 Property Constantsn2	(N2)  A property constant is named by its property constant identifier or the qualified name specified by the property set/property constant identifier pair, separated by double colon (“::”). An unqualified property constant identifier must be part of the predeclared property sets. Otherwise, the property constant identifier must appear in the property set namespace. Legality Rules	NO
	p111.3 Property Constantsl1	(L1)  A property constant cannot be declared for the classifier property type or the reference property type.	NO
	p111.3 Property Constantsl2	(L2)  If a property constant declaration has more than one property expression, it must contain the reserved words list of.	NO
	p111.3 Property Constantsl3	(L3)  The property type of the property constant declaration must match the property type of the constant property value.	NO
	p112 Predeclared Property Setsn1	(N1)  References to predeclared properties, property types, and property constants do not have to be qualified with the property set name. As a consequence the predeclared properties, property types, and property constants must be unique across all predeclared property sets. SAE AS5506B - 203 - NOTE: References to predeclared properties, property constants, and property types may be qualified with their property set name. Legality Rules	NO
	p112 Predeclared Property Setsl1	(L1)  The predeclared property sets other than AADL_Project cannot be modified.	NO
	p112 Predeclared Property Setsl2	(L2)  Existing property type and property constant declarations in the AADL_Project property set can be modified. New declarations must not be added to the AADL_Project property set, but can be introduced through a separate property set declaration.	NO
	p113 Property Associationsn1	(N1)  A property is named by an optional property set identifier followed by a property identifier, separated by a double colon (“::”).	NO
	p113 Property Associationsn2	(N2)  The property set identifier, if present, must appear in the global namespace and must be the defining identifier in a property set declaration.	NO
	p113 Property Associationsn3	(N3)  The property identifier must exist in the namespace of the property set, or if the optional property set identifier is absent, in the namespace of any predeclared property set.	NO
	p113 Property Associationsn4	(N4)  A property name may appear in the property association clause only if the respective AADL model element is listed in the applies to list of the property definition declaration.	NO
	p113 Property Associationsn5	(N5)  The contained model element path identifies named model elements in the containment hierarchy, for which the property value holds. The model element with the contained property association is the root of a path.	NO
	p113 Property Associationsn6	(N6)  For contained property associations declared with classifiers, e.g., a component type or component implementation, the first identifier in the path must appear in the local namespace of the classifier to which the property association belongs.	NO
	p113 Property Associationsn7	(N7)  For contained property associations declared with model elements with a classifier reference, e.g., subcomponents, the first identifier must appear as a identifier within the local namespace of the classifier that is referenced by the model element.	NO
	p113 Property Associationsn8	(N8)  Subsequent identifiers in a contained model element path must appear in the namespace of the model element identified by the preceding identifier.	NO
	p113 Property Associationsn9	(N9)  The annex identifier named in a contained model element path must be that of an approved or project-specific annex.	NO
	p113 Property Associationsn10	(N10) Identifiers in an annex-specific path must appear in the namespace of the identified annex in the context of the  namespace of the model element identified by the preceding identifier.	NO
	p113 Property Associationsn11	(N11) If the identifier of a contained model element path is a subcomponent array identifier, it can specify a  subcomponent array as a whole, an array subset, or an individual array element.	NO
	p113 Property Associationsn12	(N12) If a property association has an in binding statement, then the unique platform classifier reference must be  referenceable according to the with and renames declarations.	NO
	p113 Property Associationsn13	(N13) If a property association has mode-specific values, i.e., an in modes statement for values, then the mode must  refer to a mode of the component the property is associated with, or in the case of a property association of model elements that are not components, the modes of the containing component.	NO
	p113 Property Associationsn14	(N14) A property association list must have at most one property association for the same property. In case of bindingspecific property associations, there must be at most one association for each binding.  Legality Rules	NO
	p113 Property Associationsl1	(L1)  The property definition named by a property association must list the class of the model element, with which the property is associated, or any of its super classes in its applies to clause. SAE AS5506B - 206 -	NO
	p113 Property Associationsl2	(L2)  A contained property association with mode-specific values can only be applied to a single model element, i.e., can only contain a single containment path.	NO
	p113 Property Associationsl3	(L3)  If a property expression list consists of a list of two or more property expressions, all of those property expressions must be of the same property type.	NO
	p113 Property Associationsl4	(L4)  If the property declaration for the associated property definition does not contain the reserved words list of, the property value must be a single property value. If the property declaration for the associated property definition contains the reserved words list of, the property list value must have the correct number of parentheses to match the list or nested list declaration.	NO
	p113 Property Associationsl5	(L5)  The property association operator +=> must only be used if the property declaration for the associated property definition contains the reserved words list of.	NO
	p113 Property Associationsl6	(L6)  A property association with an operator +=> must not have an in modes or in binding statement.	NO
	p113 Property Associationsl7	(L7)  The property association operator +=> must not be used in contained property associations.	NO
	p113 Property Associationsl8	(L8)  In a property association, the type of the evaluated property expression must match the property type of the named property.	NO
	p113 Property Associationsl9	(L9)  A property value declared by a property association with the reserved word constant cannot be changed when the rules in the semantics section for determining a property value are followed.	NO
	p113 Property Associationsl10	(L10) The unique component type identifiers in the in binding statement must refer to component types of the categories  processor, virtual processor, bus, virtual bus, or memory.	NO
	p113 Property Associationsl11	(L11) If a property value with an in modes statement is associated with a connection, flow implementation, or call  sequence with an in modes statement, then the set of modes for which the property value applies must be contained in the set of modes for which the connection, flow implementation, or call sequence is active. Consistency Rules	NO
	p113 Property Associationsc1	(C1) If a property association has mode-specific values, i.e., values declared with the in modes statement, then the  modal value assignment must include a value for each mode. If the modal value assignment includes a value without the in modes statement, this value becomes the default for all modes without an explicit mode-specific value.	NO
	p114 Property Expressionsn1	(N1)  The component type identifier or component implementation name of a subcomponent classifier reference must appear namespace of the specified package. SAE AS5506B - 211 -	NO
	p114 Property Expressionsn2	(N2)  The enumeration identifier of a property expression must have been declared in the enumeration list of the property type that is associated with the property.	NO
	p114 Property Expressionsn3	(N3)  For reference terms the naming rules (N5) .. (N11) in Section 11.3 are applicable in order to resolve contained model element paths.	NO
	p114 Property Expressionsn4	(N4)  If a classifier property is associated with a core AADL model element, then the classifier meta model identifier of a classifier term can only refer to a core AADL meta model class.	NO
	p114 Property Expressionsn5	(N5)  If a classifier property is associated with an AADL annex model element, then the classifier meta model identifier of a classifier term can refer to a core AADL meta model class or an annex meta model class of the same annex.	NO
	p114 Property Expressionsn6	(N6)  If a reference property is associated with a core AADL model element, then the contained model element path of a reference term can only refer to a core AADL model element. The first identifier in the path must be defined in the namespace of the directly enclosing component that contains the property association.	NO
	p114 Property Expressionsn7	(N7)  If a reference property is associated with an AADL annex model element, then the contained model element path of a reference term can refer to a core AADL model element or an annex model element of the same annex.	NO
	p114 Property Expressionsn8	(N8)  The field identifier of a record expression must exist in the local namespace of the record type.	NO
	p114 Property Expressionsn9	(N9)  The function identifier of a compute expression must exist as function in the source text. Legality Rules	NO
	p114 Property Expressionsl1	(L1)  If the base type of a property number type or range type is integer, then the numeric literals must be integers.	NO
	p114 Property Expressionsl2	(L2)  The type of a property named in a property term must be identical to the type of the property name in the property association.	NO
	p114 Property Expressionsl3	(L3)  The type of a property constant named in a property constant term must match the type of the property name in the property association.	NO
	p114 Property Expressionsl4	(L4)  Property references in property_term or property_constant_term of property expressions must be applicable to the model element to which the property association applies.	NO
	p114 Property Expressionsl5	(L5)  Property references in property_term or property_constant_term of property expressions cannot be circular. If a property has a