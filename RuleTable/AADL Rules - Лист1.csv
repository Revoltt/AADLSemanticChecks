SECTION NAME,ID,RULE TEXT,POSITIVE,NEGATIVE,COMMENTARY
AADL Specifications,p41n1,(N1)  An AADL specification has one global namespace. The package and property set identifiers reside in this space and must be unique.,0,0,Checked by DFS during processing package nodes
AADL Specifications,p41n2,(N2)  These package and property set identifiers qualify the names of individual elements contained in them when they are referenced.,0,0,0
AADL Specifications,p41n3,"(N3)  Package declarations represent labeled namespaces for component type, component implementation, feature group type, and annex library declarations.",0,0,0
AADL Specifications,p41n4,(N4)  Property set declarations represent labeled namespaces for property type and property definition declarations.,0,0,0
AADL Specifications,p41n5,(N5)  Packages and property sets may be separately stored. Those packages and property sets are considered to be part of the global namespace.,0,0,Provided by parser
AADL Specifications,p41n6,(N6)  Defining identifiers in AADL must not be one of the reserved words of the language (see Section 15.7).,0,0,Provided by parser
AADL Specifications,p41n7,(N7)  The AADL identifiers and reserved words can be in upper or lower case (or a mixture of the two) (see Section 15).,0,0,Should be mentioned when working with identifiers
AADL Specifications,p41n8,(N8)  The AADL does not require that an identifier be declared before it is referenced.,0,0,0
Packages,p42n1,(N1)  A defining package name consists of a sequence of one or more package identifiers separated by a double colon (вЂњ::вЂќ). A defining package name must be unique in the global namespace.,0,0,Checked by counting private and public package declarations in DFS during processing package nodes
Packages,p42n2,(N2)  The public and private section of a package may be declared in separate package declarations; these two declarations introduce a single defining package name.,0,0,Provided by parser
Packages,p42n3,"(N3)  Associated with every package is a package namespace that contains the names for all the elements defined within that package. This means that component types, feature group types, and defining entities declared in an annex library using an annex-specific sublanguage can be declared with the same name in different packages.",0,0,0
Packages,p42n4,(N4)  The package namespace is divided into a public section and a private section. Items declared in the public section of the package namespace can be referenced from outside the package as well as within the package.,0,0,0
Packages,p42n5,"(N5)  The reference to an item declared in another package must be an item name qualified with a package name separated by a double colon (вЂњ::вЂќ). The package name must be listed in the import_declaration (with) of the package with the reference, i.e., in the import_declaration of the public section, if the reference is in the public section, and in the import_declaration of the public or private section if the reference is in the private section of the package. Only classifiers in the public package section can be referenced.",0,0,0
Packages,p42n6,"(N6)  The reference to a property other than predeclared properties must be an property name qualified with a property set name separated by a double colon (вЂњ::вЂќ). The property set name must be listed in the with declaration of the package with the reference. Predeclared properties may be, but are not required to be qualified by the property set name.",0,0,0
Packages,p42n7,(N7)  The package name in a import_declaration must exist in the global name space.,0,0,Checked by DFS during processing package nodes
Packages,p42n8,(N8)  The property set identifier in a import_declaration must exist in the global name space.,0,0,Checked by DFS during processing package nodes
Packages,p42n9,(N9)  Items declared in the private section of the package can only be referenced from within the private section of the package.,0,0,0
Packages,p42n10,"(N10) If the qualifying package identifier of a qualified reference is missing, the referenced component classifier, feature  group type, or item in an annex library must exist in the same package as the reference.",0,0,0
Packages,p42n11,(N11) The package name referenced in an alias_declaration must exist in the global namespace and must be  listed in the import_declaration.,0,0,0
Packages,p42n12,(N12) The classifier referenced by the alias_declaration must exist in the name space of the public section of the  package being referenced by the alias_declaration.,0,0,0
Packages,p42n13,(N13) The classifier referenced by the alias declaration must refer to a component type or a feature group type.,0,0,0
Packages,p42n14,(N14) The defining identifier of an alias_declaration must be unique in the namespace of the package containing  the alias_declaration. If an alias_declaration defines an alias for a package then the alias name must not conflict with any package name listed in an import_declaration or that of the package containing the alias_declaration.,0,0,0
Packages,p42n15,(N15) The alias_declaration makes the publicly visible identifier of classifiers declared in another package  accessible in the name space of the package containing the alias_declaration. If the alias declaration for a classifier does not include a defining identifier then the referenced classifier identifier is used as defining identifier and this identifier must be unique in the namespace of the package with the alias declaration.,0,0,0
Packages,p42n16,"(N16) If the alias_declaration renames all publicly visible identifiers of component types and feature group types  by naming the package and all, then all those identifiers must also be unique in the namespace of the package with the alias declaration.",0,0,0
Packages,p42n17,"(N17) The identifiers introduced by the alias_declaration are only accessible within the package. When declared in  the public package section, they can be referenced within the public and private package section, but not from other packages. When declared in the private package section, they can be referenced within the private package section only.",0,0,0
Packages,p42n18,(N18) The alias declared for a component type can be used instead of a qualified component type in a reference to a  component implementation.,0,0,0
Packages,p42l1,(L1)  The defining package name following the reserved word end must be identical to the defining package name following the reserved word package.,0,0,0
Packages,p42l2,(L2)  For each package there may be at most one public section declaration and one private section declaration. These two sections may be declared in a single package declaration or in two separate package declarations.,0,0,0
Packages,p42l3,(L3)  A component implementation may be declared in both the public and private part of a package. In that case the declaration in the public part may only contain a properties subclause and a modes subclause.,0,0,0
Packages,p42l4,(L4)  The component category in an alias declaration must match the category of the referenced component type.,0,0,0
Component Types,p43n1,(N1)  The defining identifier for a component type must be unique in the namespace of the package within which it is declared.,0,0,0
Component Types,p43n2,"(N2)  Each component type has a local namespace for defining identifiers of prototypes, features, modes, mode transitions, and flow specifications. That is, defining prototype, defining feature, defining modes and mode transitions, and defining flow specification identifiers must be unique in the component type namespace.",0,0,0
Component Types,p43n3,"(N3)  The component type identifier of the ancestor in a component type extension, i.e., that appears after the reserved word extends, must be defined in the specified package namespace. If no package name is specified, then the identifier must be defined in the namespace of the package the extension is declared in.",0,0,0
Component Types,p43n4,"(N4)  When a component type extends another component type, a component type namespace includes all the identifiers in the namespaces of its ancestors.",0,0,0
Component Types,p43n5,(N5)  A component type that extends another component type does not include the identifiers of the implementations of its ancestors.,0,0,0
Component Types,p43n6,"(N6)  The defining identifier of a feature, flow specification, mode, mode transition, or prototype must be unique in the namespace of the component type.",0,0,0
Component Types,p43n7,"(N7)  The refinement identifier of a feature, flow specification, or prototype refinement refers to the closest refinement or the defining declaration of the feature going up the component type ancestor hierarchy.",0,0,0
Component Types,p43n8,(N8)  The prototypes referenced by prototype binding declarations must exist in the local namespace of the component type being extended.,0,0,0
Component Types,p43n9,(N9)  Mode transitions declared in the component type may not refer to event or event data ports of subcomponents.,0,0,0
Component Types,p43l1,(L1)  The defining identifier following the reserved word end must be identical to the defining identifier that appears after the component category reserved word.,0,0,0
Component Types,p43l2,"(L2)  The prototypes, features, flows, modes, and properties subclauses are optional. If a subclause is present but empty, then the reserved word none followed by a semi-colon must be present.",0,0,0
Component Types,p43l3,"(L3)  The category of the component type being extended must match the category of the extending component type, i.e., they must be identical or the category being extended must be abstract.",0,0,0
Component Types,p43l4,"(L4)  The classifier being extended in a component type extension may include prototype bindings. There must be at most one prototype binding for each prototype, i.e., once bound a prototype binding cannot be overwritten by a new binding in a component type extension.",0,0,0
Component Types,p43l5,(L5)  A component type must not contain both a requires_modes_subclause and a modes_subclause.,0,0,0
Component Types,p43l6,"(L6)  If the extended component type and an ancestor component type in the extends hierachy contain modes subclauses, they must both be requires_modes_subclause or modes_subclause. Standard Properties Classifier_Substitution_Rule: inherit enumeration (Classifier_Match, Signature_Match) Type_Extension, Prototype_Substitution_Rule: inherit enumeration (Classifier_Match, Type_Extension, Signature_Match)",0,0,0
Component Implementations,p44n1,"(N1)  A component implementation name consists of a component type identifier and a component implementation identifier separated by a dot (вЂњ.вЂќ). The first identifier of the defining component implementation name must name a component type that is declared in the same package as the component implementation, or name an alias to a component type in another package.",0,0,0
Component Implementations,p44n2,(N2)  The defining identifier of the component implementation must be unique within the local namespace of the component type.,0,0,0
Component Implementations,p44n3,"(N3)  Every component implementation defines a local namespace for all defining identifiers of prototypes, subcomponents, subprogram calls, connections, flows, and modes declared within the component implementation. The defining identifier of a prototype, subcomponent, subprogram call, connection, flow, or mode must be unique within this namespace. For example, a subcomponent and a mode cannot have the same defining identifier within the same component implementation, or a mode with the same defining identifier cannot be declared in a component type and a component implementation.",0,0,0
Component Implementations,p44n4,"(N4)  This local namespace inherits the namespace of the associated component type, i.e., defining identifiers must be unique within the local namespace and also within the component type namespace.",0,0,0
Component Implementations,p44n5,"(N5)  Refinement identifiers of features must exist in the namespace of the associated component type or one of the component typeвЂ™s ancestors. Refinement identifiers of prototype, subcomponent, and connection refinements must exist in the local namespace of an ancestor component implementation.",0,0,0
Component Implementations,p44n6,"(N6)  In a component implementation extension, the component type identifier of the component implementation being extended, which appears after the reserved word extends, must be the same as or an ancestor of the component type of the extension. The component implementation being extended may exist in another package. In this case the component implementation name is qualified with the package name.",0,0,0
Component Implementations,p44n7,"(N7)  When a component implementation extends another component implementation, the local namespace of the extension is a superset of the local namespace of the ancestor. That is, the local namespace of a component implementation inherits all the identifiers in the local namespaces of its ancestors (including the identifiers of their respective component type namespaces). SAE AS5506B - 42 -",0,0,0
Component Implementations,p44n8,"(N8)  Within the scope of the component implementation, subcomponent declarations, connections, subprogram call sequences, mode transitions, and property associations can refer directly to identifiers in the local namespace, i.e., to declared prototypes, subcomponents, connections, and modes, as well as to required bus, data, subprogram, and subprogram group subcomponents and features declared in the associated component type.",0,0,0
Component Implementations,p44n9,"(N9)  The prototype referenced by the prototype binding declaration must exist in the local namespace of the component implementation being extended. In other words, prototype binding declarations may bind prototypes of the component type and of the component implementation.",0,0,0
Component Implementations,p44l1,(L1)  The pair of identifiers separated by a dot (вЂњ.вЂќ) following the reserved word end must be identical to the pair of identifiers following the reserved word implementation.,0,0,0
Component Implementations,p44l2,"(L2)  The prototypes, subcomponents, connections, calls, flows, modes, and properties subclauses are optional. If they are present and the set of feature or required subcomponent declarations or property associations is empty, none followed by a semi-colon must be present in that subclause.",0,0,0
Component Implementations,p44l3,(L3)  The category of the component implementation must be identical to the category of the component type for which the component implementation is declared.,0,0,0
Component Implementations,p44l4,"(L4)  If the component implementation extends another component implementation, the category of both must match, i.e., they must be identical or the category being extended must be abstract.",0,0,0
Component Implementations,p44l5,(L5)  The classifier being extended in a component implementation extension may include prototype bindings. There must be at most one prototype binding for each unbound prototype.,0,0,0
Component Implementations,p44l6,(L6)  If the component type of the component implementation contains a requires_modes_subclause then the component implementation must not contain any modes subclause.,0,0,0
Component Implementations,p44l7,"(L7)  If modes are declared in the component type, then modes cannot be declared in component implementations.",0,0,0
Component Implementations,p44l8,"(L8)  If modes or mode transitions are declared in the component type, then mode transitions can be added in the component implementation. These mode transitions may refer to event or event data ports of the component type and of subcomponents.",0,0,0
Component Implementations,p44l9,"(L9)  The category of a subcomponent being refined must match the category of the refining subcomponent declaration, i.e., they must be identical or the category being refined must be abstract.",0,0,0
Component Implementations,p44l10,(L10) For all other refinement declarations the categories must match (see the respective sections).,0,0,0
Component Implementations,p44l11,(L11) Component implementations and component implementation extensions must not refine prototypes declared in a  component type.,0,0,0
Subcomponents,p45n1,(N1)  The defining identifier of a subcomponent declaration placed in a component implementation must be unique within the local namespace of the component implementation that contains the subcomponent.,0,0,0
Subcomponents,p45n2,(N2)  The defining identifier of a subcomponent refinement must exist as a defining subcomponent identifier in the local namespace of an ancestor component implementation.,0,0,0
Subcomponents,p45n3,(N3)  The component type identifier or the component implementation name of a component classifier reference must exist in the package namespace.,0,0,0
Subcomponents,p45n4,(N4)  The prototype identifier of a prototype reference must exist in the local name space of the component implementation.,0,0,0
Subcomponents,p45n5,(N5)  The prototype referenced by the prototype binding declarations must exist in the local namespace of the component classifier being referenced.,0,0,0
Subcomponents,p45n6,"(N6)  The modes named in the in modes statement of a subcomponent must refer to modes in the component implementation that contains the subcomponent or its component type. The modes named in the in modes statement of a property association of a subcomponent must refer to modes of the subcomponent, or in the case of a contained property association to modes of the last component in the component path (see Section 11.3).",0,0,0
Subcomponents,p45l1,"(L1)  The category of the subcomponent declaration must match the category of its corresponding component classifier reference or its prototype reference, i.e., they must be identical, or in the case of a classifier reference the referenced classifier category may be abstract.",0,0,0
Subcomponents,p45l2,(L2)  The component classifier reference of a subcomponent declaration may include prototype bindings for a subset or all of the component classifier prototypes. This represents an unnamed component classifier extension of the referenced classifier.,0,0,0
Subcomponents,p45l3,(L3)  In a subcomponent refinement declaration the component category may be refined from abstract to one of the concrete component categories. Otherwise the category must be the same as that of the subcomponent being refined.,0,0,0
Subcomponents,p45l4,"(L4)  The Classifier_Substitution_Rule property specifies the rule to be applied when a refinement supplies a classifier and the original subcomponent declaration already has a component classifier. This property can be applied to individual subcomponents or features, or it can be inherited from classifiers. The following rules are supported: вЂў вЂў вЂў Classifier_Match: The component type of the refinement must be identical to the component type of the classifier being refined. If the original declaration specifies a component implementation, then any implementation of that type can replace this original implementation. This is the default rule. Type_Extension: Any component classifier whose component type is an extension of the component type of the classifier in the subcomponent being refined is an acceptable substitute. Signature_Match: The component type of the refinement must match the signature of the component type of the classifier being refined. ",0,0,0
Subcomponents,p45l5,"(L5)  In the case of a signature match, the component type of the subcomponent being refined must have a subset of the features of the component type in the refinement. The features are compared by name matching; the feature categories and direction (in data port, provides data access, etc.) must be the same and any feature classifier must match according to rules defined for Classifier_Match. In addition, if flow specifications are present in the component type being refined, then the component type of the refinement must have at least the same set of flow specifications. Flow specifications with the same name must have the same source and destination ports.",0,0,0
Subcomponents,p45l6,(L6)  The component category and optional component classifier or prototype reference can be followed by a set of array dimensions to define the subcomponent as an array of actual subcomponents.,0,0,0
Subcomponents,p45l7,(L7)  The array size specification for the dimensions is optional. In this case the array declaration is considered incomplete. If the size of the array dimension is specified it must be specified for all dimensions in the same declaration.,0,0,0
Subcomponents,p45l8,"(L8)  When refining a subcomponent array the number of dimensions of the array cannot be changed, but the array size can be specified for each dimension if it was not specified in the subcomponent declaration being refined.",0,0,0
Subcomponents,p45l9,"(L9)  When the subcomponent is declared as an array with array dimension sizes then a list of component implementations can be supplied, one for each element of the array. Different implementations of the same component type can be chosen. The number of elements in the list must correspond to the number of elements in the component array. In the case of multi-dimensional arrays, the list elements are assigned by incrementing the index of the last dimension first.",0,0,0
Subcomponents,p45l10,(L10) Selecting index ranges in one or more dimensions of an array is only possible if the size of the array for these  dimensions is already defined. The index range of a dimension is from 1 to the size of the dimension. Specification of array index ranges is limited to the applies to subclause of contained property associations. Specification of a single array element is limited to the applies to subclause of contained property associations and to the values of reference properties.,0,0,0
Subcomponents,p45l11,(L11) An array element implementation list is valid only if (a) the subcomponent classifier is a component type and (b) all  component implementations in the list are implementations of the specified type.,0,0,0
Subcomponents,p45c1,"(C1) The classifier of a subcomponent cannot recursively contain subcomponents with the same component classifier.  In other words, there cannot be a cyclic containment dependency between components. Standard Properties Classifier_Substitution_Rule: inherit enumeration (Classifier_Match, Signature_Match) Type_Extension, Acceptable_Array_Size: list of Size_Range",0,0,0
Abstract Components,p46l1,"(L1)  An abstract component type declaration can contain feature declarations (including abstract feature declarations), flow declarations, as well as property associations.",0,0,0
Abstract Components,p46l2,(L2)  An abstract component implementation can contain subcomponent declarations of any category. Certain combinations of subcomponent categories are only acceptable if they are acceptable in one of the concrete component categories.,0,0,0
Abstract Components,p46l3,"(L3)  An abstract component implementation can contain a modes subclause, a connections subclause, a flows subclause, and property associations.",0,0,0
Abstract Components,p46l4,(L4)  An abstract subcomponent can be contained in the implementation of any component category.,0,0,0
Abstract Components,p46l5,"(L5)  If an abstract subcomponent is refined to a concrete category, the concrete category must be acceptable to the component implementation category whose subcomponent is being refined.",0,0,0
Abstract Components,p46l6,(L6)  An abstract subcomponent can be declared as an array of subcomponents.,0,0,0
Abstract Components,p46l7,"(L7)  If an abstract component type is refined to a concrete category, the features, modes, and flow specifications of the abstract component type must be acceptable for the concrete component type.",0,0,0
Abstract Components,p46l8,"(L8)  If an abstract component implementation is refined to a concrete category, the subcomponents, call sequences, modes, flow implementations, and end-to-end flows of the abstract component implementation must be acceptable for the concrete component implementation. Standard Properties (2) An abstract component can have property associations of properties that apply to any concrete category. However, when refined to a concrete category, properties that do not apply to the concrete category will be ignored. A method of processing may provide a warning about ignored propertie",0,0,0
Prototypes,p47n1,(N1)  The prototype identifier on the left-hand side of a prototype binding must exist in the local namespace of the classifier for which the prototype binding is defined.,0,0,0
Prototypes,p47n2,"(N2)  The prototype identifier on the right-hand side of a prototype binding, if present, must exist in the local namespace of the classifier that contains the prototype binding.",0,0,0
Prototypes,p47n3,(N3)  Unique component classifier references must exist in the public section of the package being identified in the reference.,0,0,0
Prototypes,p47n4,(N4)  Unique feature group type references must exist in the public section of the package being identified in the reference.,0,0,0
Prototypes,p47l1,"(L1)  The component category declared in the component prototype binding must match the component category of the prototype being referenced, i.e., they must be identical, or the declared category component category of the prototype must be abstract.",0,0,0
Prototypes,p47l2,(L2)  The component category of the optional component classifier reference in the prototype declaration must match the category in the prototype declaration.,0,0,0
Prototypes,p47l3,"(L3)  If the component prototype only specifies a component category, then any component type and component implementation of that category is acceptable; in the case of the category abstract any component type and component implementation of any category is acceptable.",0,0,0
Prototypes,p47l4,"(L4)  If the component prototype declaration includes a component classifier reference, then the classifier supplied in the prototype binding must match according to the Prototype_Substitution_Rule property. This property specifies the rules to be applied to determine an acceptable classifier supplied to the prototype. This property can be associated with a prototype declaration or the enclosing component type or component implementation. The rules are the same as those of the Classifier_Substitution_Rule property.",0,0,0
Prototypes,p47l5,"(L5)  The category of the component implementation that contains the prototype declaration places restrictions on the set of acceptable categories for the prototype declaration and the supplied classifiers. The nesting rules for each category are defined in the respective component category section of this document. For example, if the component implementation is a thread group implementation, then the prototype referenced in a subcomponent declaration must be of the category thread group, thread, subprogram, subprogram group, data, or abstract.",0,0,0
Prototypes,p47l6,"(L6)  If the direction is declared for feature prototypes, then the prototype actual satisfies the direction according to the same rules as for feature refinements (see Section 8); in the case of ports the direction must be in or out; in the case of data access, the access right must be read-only for in and write-only for out; in the case of bus access, subprogram access and subprogram group access the direction is ignored.",0,0,0
Prototypes,p47l7,"(L7)  In the case of feature group prototypes, the supplied feature group types must match the declared feature group type, if any. The Prototype_Substitution_Rule property rules apply to feature group types instead of component types.",0,0,0
Prototypes,p47l8,"(L8)  A classifier supplied in a feature prototype binding must match the classifier of the prototype declaration, if present, according to the Prototype_Substitution_Rule property rules.",0,0,0
Prototypes,p47l9,(L9)  Component prototypes declared with square brackets specify that they expect a list of component classifiers. These prototypes can only be referenced in subcomponent array declarations. The component classifier list supplies the classifiers for each of the elements in the component array.,0,0,0
Prototypes,p47l10,(L10) The component category of the classifier reference or prototype reference in a prototype binding declaration must  match the category of the prototype.,0,0,0
Prototypes,p47l11,"(L11) If a direction is specified for an abstract feature in a prototype declaration, then the direction of the prototype actual  must match that declared in the prototype.",0,0,0
Prototypes,p47l12,"(L12) Component prototype bindings must only bind component prototypes, feature group prototype bindings must only  bind feature group prototypes, and feature bindings must only bind feature prototypes.",0,0,0
Prototypes,p47l13,"(L13) Component prototype refinements must only refine component prototypes, feature group prototype refinements  must only refine feature group prototypes, and feature refinements must only refine feature prototypes. SAE AS5506B - 58 - Standard Properties Prototype_Substitution_Rule: inherit enumeration (Classifier_Match, Type_Extension, Signature_Match)",0,0,0
Annex Subclauses and Annex Libraries,p48n1,(N1)  The annex identifier must be the name of an approved annex or a project-specific identifier different from the approved annex identifiers.,0,0,0
Annex Subclauses and Annex Libraries,p48n2,(N2)  The mode identifiers in the in_modes statement must refer to modes in the component type or component implementation for which the annex subclause is declared.,0,0,0
Annex Subclauses and Annex Libraries,p48l1,"(L1)  Annex subclauses can only be declared in component types, component implementations, and feature group types.",0,0,0
Annex Subclauses and Annex Libraries,p48l2,"(L2)  A component type, component implementation, or feature group type declaration may contain at most one annex subclause for each annex. If the annex subclause has an in_modes statement, then there must be at most one annex subclause per mode for each annex.",0,0,0
Annex Subclauses and Annex Libraries,p48l3,(L3)  Annex libraries must be declared in packages.,0,0,0
Annex Subclauses and Annex Libraries,p48l4,(L4)  A package declaration may contain at most one annex library declaration for each annex.,0,0,0
Data,p51l1,(L1)  A data type declaration can contain provides subprogram access declarations as well as property associations.,0,0,0
Data,p51l2,(L2)  A data type declaration must not contain a flow specification or modes subclause.,0,0,0
Data,p51l3,"(L3)  A data implementation can contain abstract, data and subprogram subcomponents, access connections, and data property associations.",0,0,0
Data,p51l4,"(L4)  A data implementation must not contain a flow implementation, an end-to-end flow specification, or a modes subclause. Standard Properties Source_Data_Size: Size Source_Code_Size: Size Type_Source_Name: aadlstring Source_Name: aadlstring Source_Text: inherit list of aadlstring -- hardware mapping Base_Address: aadlinteger 0 .. Max_Base_Address Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Actual_Memory_Binding: inherit list of reference (memory) -- Data sharing properties Access_Right : Access_Rights => read_write Concurrency_Control_Protocol: Supported_Concurrency_Control_Protocols SAE (5) AS5506B - 64 - The value of the Type_Source_Name property identifies the name of the data type declaration in the source text. The value of the Source_Name property identifies the name of the static or local data variable in the source text.",0,0,0
Subprograms and Subprogram Calls,p52n1,(N1)  The defining identifier of a subprogram call sequence declaration must be unique within the local namespace of the component implementation that contains the subprogram call sequence.,0,0,0
Subprograms and Subprogram Calls,p52n2,(N2)  The defining identifier of a subprogram call declaration must be unique within the local namespace of the component implementation that contains the subprogram call.,0,0,0
Subprograms and Subprogram Calls,p52n3,"(N3)  If the called subprogram name is a subprogram classifier reference, its component type identifier or component implementation name must exist in the package namespace.",0,0,0
Subprograms and Subprogram Calls,p52n4,(N4)  The subprogram classifier reference of a subprogram call may be a subprogram type reference.,0,0,0
Subprograms and Subprogram Calls,p52n5,"(N5)  If the called subprogram name is a subprogram subcomponent reference, the subprogram subcomponent must exist in the component implementation containing the subprogram call declaration.",0,0,0
Subprograms and Subprogram Calls,p52n6,"(N6)  If the called subprogram name is a requires subprogram access reference, the requires subprogram access must exist in the component type of the component implementation containing the subprogram call declaration.",0,0,0
Subprograms and Subprogram Calls,p52l1,"(L1)  A subprogram type declaration can contain parameter, out event port, out event data port, and feature group declarations as well as requires data, subprogram, and subprogram group access declarations. It can also contain a flow specification subclause, a modes subclause, and property associations.",0,0,0
Subprograms and Subprogram Calls,p52l2,"(L2)  A subprogram implementation can contain abstract, subprogram, and data subcomponents, a subprogram calls subclause, a connections subclause, a flows subclause, a modes subclause, and property associations.",0,0,0
Subprograms and Subprogram Calls,p52l3,(L3)  Only one subprogram call sequence can apply to a given mode.,0,0,0
Subprograms and Subprogram Calls,p52c1,(C1) The reference to a provides subprogram access of a processor in a subprogram call (processor .  provides_subprogram_access_identifier) must identify a provides subprogram access feature of the processor that the thread executing the call is bound to.,0,0,0
Subprograms and Subprogram Calls,p52c2,"(C2) A subprogram call may reference a subprogram classifier. A project may enforce a consistency rule that this  reference be to a subprogram subcomponent declaration or requires subprogram access declaration. This ensures that a modeler consistently models subprogram calls the same way. Standard Properties -- Properties related to source text Source_Name: aadlstring Source_Text: inherit list of aadlstring Source_Language: inherit list of Supported_Source_Languages Type_Source_Name: aadlstring -- Properties specifying memory requirements of subprograms Source_Code_Size: Size Source_Data_Size: Size Source_Stack_Size: Size SAE AS5506B - 71 - Source_Heap_Size: Size Allowed_Memory_Binding_Class: inherit list of classifier (memory, system, processor) Allowed_Memory_Binding: inherit list of reference (memory, system, processor) Actual_Memory_Binding: inherit list of reference (memory) -- execution related properties Compute_Execution_Time: Time_Range Compute_Deadline: Time Client_Subprogram_Execution_Time: Time_Range Reference_Processor: inherit classifier ( processor ) -- remote subprogram call related properties Urgency: aadlinteger 0 .. Max_Urgency Actual_Subprogram_Call: reference (subprogram) Allowed_Subprogram_Call: list of reference (subprogram) Actual_Subprogram_Call_Binding: list of reference (bus, processor, memory, device) Allowed_Subprogram_Call_Binding: inherit list of reference (bus, processor, device) Subprogram_Call_Type: enumeration (Synchronous, SemiSynchronous) => Synchronous",0,0,0
Subprogram Groups and Subprogram Group Types,p53n1,(N1)  The defining identifier of a subprogram group type must be unique within the package namespace of the package where the subprogram group type is declared.,0,0,0
Subprogram Groups and Subprogram Group Types,p53n2,(N2)  Each subprogram group provides a local namespace. The defining subprogram identifiers of subprogram declarations in a subprogram group type must be unique within the namespace of the subprogram group type.,0,0,0
Subprogram Groups and Subprogram Group Types,p53n3,"(N3)  The local namespace of a subprogram group type extension includes the defining identifiers in the local namespace of the subprogram group type being extended. This means, the defining identifiers of subprogram or subprogram group declarations in a subprogram group type extension must not exist in the local namespace of the subprogram group type being extended. The defining identifiers of subprogram or subprogram group refinements in a subprogram group type extension must refer to a subprogram or subprogram group in the local namespace of an ancestor subprogram group type.",0,0,0
Subprogram Groups and Subprogram Group Types,p53n4,(N4)  The defining subprogram identifiers of subprogram access feature declarations in feature group refinements must not exist in the local namespace of any subprogram group being extended. The defining subprogram identifier of subprogram_refinement declarations in subprogram group refinements must exist in the local namespace of any feature group being extended.,0,0,0
Subprogram Groups and Subprogram Group Types,p53n5,(N5)  The package name of the unique subprogram group type reference must refer to a package name in the global namespace. The subprogram group type identifier of the unique subprogram group type reference must refer to a subprogram group type identifier in the named package.,0,0,0
Subprogram Groups and Subprogram Group Types,p53l1,"(L1)  A subprogram group type can contain provides and requires subprogram access, and provides and requires subprogram group access.",0,0,0
Subprogram Groups and Subprogram Group Types,p53l2,"(L2)  A subprogram group implementation can contain abstract, data, subprogram group, and subprogram subcomponents as well as data and subprogram access connections.",0,0,0
Subprogram Groups and Subprogram Group Types,p53l3,"(L3)  A subprogram group type or implementation may contain zero or more subcomponent declarations. If it contains zero elements, then the subprogram group type or implementation is considered to be incompletely specified.",0,0,0
Threads,p54l1,"(L1)  A thread type declaration can contain port, feature group, requires data access declarations, as well as requires and provides subprogram access declarations. It can also contain flow specifications, a modes subclause, and property associations.",0,0,0
Threads,p54l2,"(L2)  A thread component implementation can contain abstract, data, subprogram, and subprogram group subcomponent declarations, a calls subclause, a flows subclause, a modes subclause, and thread property associations.",0,0,0
Threads,p54l3,"(L3)  The Complete out event port, and Error out event data port are predeclared, i.e., are implicitly identifiers in the name space of a thread type. Therefore, there cannot be user-defined features with those names in threads.",0,0,0
Threads,p54c3,"(C3) Either  the Compute_Entrypoint, Compute_Entrypoint_Source_Text Compute_Entrypoint_Call_Sequence property must have a value that indicates the source code to execute after a thread has been dispatched when an implementation is to be generated or consistency with source code is to be checked. Other entrypoint properties are optional, i.e., if a property value is not defined, then the entrypoint is not called.",0,0,0
Threads,p54c4,"(C4) The Period property must have a value if the Dispatch_Protocol property value is periodic, sporadic, timed, or  hybrid.",0,0,0
Thread Groups,p55l1,"(L1)  A thread group component type can contain provides and requires data access, as well as port, feature group, provides and requires subprogram access declarations, and provides and requires subprogram group access declarations. It can also contain flow specifications, modes subclauses, and property associations.",0,0,0
Thread Groups,p55l2,"(L2)  A thread group component implementation can contain abstract, data, subprogram, subprogram group, thread, and thread group subcomponent declarations.",0,0,0
Thread Groups,p55l3,"(L3)  A thread group implementation can contain a connections subclause, a flows subclause, a modes subclause, and properties subclause.",0,0,0
Thread Groups,p55l4,(L4)  A thread group must not contain a subprogram calls subclause.,0,0,0
Processes,p56l1,"(L1)  A process component type can contain port, feature group, provides and requires data access, provides and requires subprogram access declarations, and provides and requires subprogram group access declarations. It can also contain flow specifications, modes subclause, and property associations.",0,0,0
Processes,p56l2,"(L2)  A process component implementation can contain abstract, data, subprogram, subprogram group, thread, and thread group subcomponent declarations.",0,0,0
Processes,p56l3,"(L3)  A process implementation can contain a connections subclause, a flows subclause, a modes subclause, and a properties subclause.",0,0,0
Processes,p56l4,(L4)  A thread group must not contain a subprogram calls subclause.,0,0,0
Processes,p56c1,(C1) The complete source text associated with a process component must form a complete and legal program as  defined in the applicable source language standard. This source text shall include the source text that corresponds to the complete set of subcomponents in the processвЂ™s containment hierarchy along with the data and subprograms that are referenced by required subcomponent declarations.,0,0,0
Processors,p61l1,"(L1)  A processor component type can contain port, feature group, provides subprogram access, provides subprogram group access, and bus access declarations. It may contain flow specifications, a modes subclause, as well as property associations.",0,0,0
Processors,p61l2,"(L2)  A processor component implementation can contain declarations of memory, bus, virtual bus, virtual processor, and abstract subcomponents.",0,0,0
Processors,p61l3,"(L3)  A processor implementation can contain a modes subclause, flows subclause, and a properties subclause.",0,0,0
Processors,p61l4,"(L4)  A processor implementation can contain bus access, subprogram access, subprogram group access, port, feature, and feature group connection declarations.",0,0,0
Processors,p61l5,(L5)  A processor implementation must not contain a subprogram calls subclause.,0,0,0
Virtual Processors,p62l1,"(L1)  A virtual processor component type can contain port, feature group, provides subprogram access, and subprogram group access declarations. It may contain flow specifications, a modes subclause, as well as property associations.",0,0,0
Virtual Processors,p62l2,"(L2)  A virtual processor component implementation can contain declarations of virtual bus, virtual processor, and abstract subcomponents.",0,0,0
Virtual Processors,p62l3,"(L3)  A virtual processor implementation can contain a modes subclause, flows subclause, and a properties subclause.",0,0,0
Virtual Processors,p62l4,(L4)  A virtual processor implementation must not contain a subprogram calls subclause.,0,0,0
Virtual Processors,p62l5,"(L5)  A virtual processor implementation can contain subprogram access, subprogram group access, port, feature, and feature group connections.",0,0,0
Virtual Processors,p62c1,"(C1) In a fully bound system every virtual processor must be directly or indirectly bound to, or directly or indirectly  contained in a physical processor.",0,0,0
Virtual Processors,p62c2,(C2) In a fully deployed system a requires virtual bus binding of a virtual processor specified by the  Required_Virtual_Bus_Class property must be satisfied by binding the virtual processor to a virtual processor or processor that provides this virtual bus. It is also satisfied if the virtual processor is contained in a processor and the respective virtual bus is bound to the processor.,0,0,0
Memory,p63l1,"(L1)  A memory type can contain bus access declarations, feature groups, a modes subclause, and property associations. It must not contain flow specifications.",0,0,0
Memory,p63l2,"(L2)  A memory implementation can contain abstract, memory, and bus subcomponent declarations.",0,0,0
Memory,p63l3,(L3)  A memory implementation can contain a modes subclause and property associations.,0,0,0
Memory,p63l4,"(L4)  A memory implementation can contain bus access connection declarations. Bus access connections can connect a memory subcomponent to a bus subcomponent or a requires bus access feature, as well as connect a provides bus access feature to a bus subcomponent.",0,0,0
Memory,p63l5,"(L5)  A memory implementation must not contain flows subclause, or subprogram calls subclause.",0,0,0
Buses,p64l1,"(L1)  A bus type can have requires bus access declarations, a modes subclause, and property associations.",0,0,0
Buses,p64l2,(L2)  A bus type must not contain any flow specifications.,0,0,0
Buses,p64l3,(L3)  A bus implementation can contain virtual bus and abstract subcomponent declarations.,0,0,0
Buses,p64l4,(L4)  A bus implementation can contain a modes subclause and property associations.,0,0,0
Buses,p64l5,"(L5)  A bus implementation must not contain flows subclause, or subprogram calls subclause.",0,0,0
Virtual Buses,p65l1,(L1)  A virtual bus type can have property associations.,0,0,0
Virtual Buses,p65l2,(L2)  A virtual bus type must not contain flow specifications.,0,0,0
Virtual Buses,p65l3,(L3)  A virtual bus implementation can contain virtual bus subcomponent declarations.,0,0,0
Virtual Buses,p65l4,(L4)  A virtual bus implementation can contain a modes subclause and property associations.,0,0,0
Virtual Buses,p65l5,"(L5)  A virtual bus implementation must not contain a connections subclause, flows subclause, or subprogram calls subclause.",0,0,0
Virtual Buses,p65c1,"(C1) In a fully deployed system virtual buses must be directly or indirectly bound to processors or buses that support  these virtual buses, or they must be subcomponents of buses and processors.",0,0,0
Devices,p66l1,"(L1)  A device type can contain port, feature group, provides subprogram access, provides subprogram group access, bus access declarations, flow specifications, a modes subclause, as well as property associations.",0,0,0
Devices,p66l2,(L2)  A device component implementation must not contain a subprogram calls subclause.,0,0,0
Devices,p66l3,"(L3)  A device implementation can contain abstract, data, virtual bus, and bus subcomponents, bus access connections, a modes subclause, a flows subclause, and property associations.",0,0,0
Systems,p71l1,"(L1)  A system component type can contain subprogram, subprogram group, data and bus access declarations, port, feature group declarations. It can also contain flow specifications as well as property associations.",0,0,0
Systems,p71l2,"(L2)  A system component implementation can contain abstract, data, subprogram, subprogram group, process, and system subcomponent declarations as well as execution platform components, i.e., processor, virtual processor, memory, bus, virtual bus, and device.",0,0,0
Systems,p71l3,"(L3)  A system implementation can contain a modes subclause, a connections subclause, a flows subclause, and property associations.",0,0,0
Systems,p71l4,(L4)  A thread group must not contain a subprogram calls subclause.,0,0,0
Systems,p71n1,(N1)  The defining identifier of a feature must be unique within the namespace of the associated component type.,0,0,0
Systems,p71n2,(N2)  Thread features may not be declared using the predeclared ports names Complete or Error.,0,0,0
Systems,p71n3,(N3)  Each refining feature identifier that appears in a feature refinement declaration must also appear in a feature declaration of a component type being extended.,0,0,0
Systems,p71n4,"(N4)  A feature is referenced in one of two ways. Within the component implementations for a component type, a feature declared in the type is named in the implementations by its identifier. Within component implementations that contain subcomponents with features, a subcomponent feature is named by the subcomponent identifier and the feature identifier separated by a вЂњ.вЂќ (dot).",0,0,0
Systems,p71n5,(N5)  The path of a contained property association for a feature must refer to an element of a feature group.,0,0,0
Systems,p71l1,(L1)  Each feature can be refined at most once in the same type extension.,0,0,0
Systems,p71l2,"(L2)  A feature refinement declaration of a feature and the original feature must both be declared as port, parameter, access feature, or feature group, or the original feature must be declared as abstract feature.",0,0,0
Systems,p71l3,"(L3)  Feature arrays must only be declared for threads, devices, and processors.",0,0,0
Systems,p71l4,"(L4)  If the feature refinement specifies an array dimension, then the feature being refined must have an array dimension.",0,0,0
Systems,p71l5,"(L5)  If the refinement specifies an array dimension size, then the feature being refined must not have an array dimension size.",0,0,0
Systems,p71l6,(L6)  A contained property association must only be used when the feature is a feature group.,0,0,0
Systems,p71l7,"(L7)  In the case of a feature with a classifier reference, the classifier of the refined feature declaration in a component type extension must adhere the classifier refinement rules indicated the Classifier_Substitution_Rule property (see Section 4.5). By default, the Classifier_Match rule applies, i.e., an incomplete classifier reference can be completed.",0,0,0
Abstract Features,p81l1,"(L1)  The feature direction in a refined feature declaration must be identical to the feature direction in the feature declaration being refined, or the feature being refined must not have a direction.",0,0,0
Abstract Features,p81l2,"(L2)  If the direction of an abstract feature is specified, then the direction must be satisfied by the refinement (see also the rules for feature prototypes in Section 4.7); in the case of ports the direction must be in or out; in the case of data access, the access right must be read-only for in and write-only for out; in the case of bus access, subprogram access and subprogram group access the direction must not be in nor out.",0,0,0
Abstract Features,p81l3,(L3)  An abstract feature with a feature prototype identifier and the prototype being referenced must both specify the same direction or no direction.,0,0,0
Abstract Features,p81l4,(L4)  An abstract feature refinement declaration of a feature with a feature prototype reference must only add property associations.,0,0,0
Feature Groups and Feature Group Types,p82n1,(N1)  The defining identifier of a feature group type must be unique within the package namespace of the package where the feature group type is declared.,0,0,0
Feature Groups and Feature Group Types,p82n2,"(N2)  Each feature group type provides a local namespace. The defining identifiers of prototype, feature, and feature group declarations in a feature group type must be unique within the namespace of the feature group type.",0,0,0
Feature Groups and Feature Group Types,p82n3,"(N3)  The local namespace of a feature group type extension includes the defining identifiers in the local namespace of the feature group type being extended. This means, the defining identifiers of prototype, feature, or feature group declarations in a feature group type extension must not exist in the local namespace of the feature group type being extended. The defining identifiers of prototype, feature, or feature group refinements in a feature group type extension must refer to a prototype, feature, or feature group in the local namespace of an ancestor feature group type.",0,0,0
Feature Groups and Feature Group Types,p82n4,(N4)  The defining feature identifiers of feature group declarations must be unique in the local name space of the component type containing the feature group declaration.,0,0,0
Feature Groups and Feature Group Types,p82n5,(N5)  The defining feature group identifier of feature_refinement declarations in component types must exist in the local namespace of the component type being extended and must refer to a feature or feature group.,0,0,0
Feature Groups and Feature Group Types,p82n6,(N6)  The package name of the unique feature group type reference must refer to a package name in the global namespace. The feature group type identifier of the unique feature group type reference must refer to a feature group type identifier in the named package.,0,0,0
Feature Groups and Feature Group Types,p82n7,(N7)  The prototype reference in a feature group declaration must refer to a prototype of the component type or feature group type that contains the feature group declaration.,0,0,0
Feature Groups and Feature Group Types,p82l1,"(L1)  A feature group type may contain zero or more elements, i.e., feature or feature groups. If it contains zero elements, then the feature group type may be declared to be the inverse of another feature group type.",0,0,0
Feature Groups and Feature Group Types,p82l2,"(L2)  A feature group type can be declared to be the inverse of another feature group type, as indicated by the reserved words inverse of and the name of a feature group type. Any feature group type named in an inverse of statement cannot itself contain an inverse of statement. This means that several feature groups can be declared to be the inverse of one feature group, e.g., B inverse of A and C inverse of A is acceptable. However, chaining of inverses is not permitted, e.g., B inverse of A and C inverse of B is not acceptable.",0,0,0
Feature Groups and Feature Group Types,p82l3,(L3)  Only feature group types without inverse of or feature group types with features and inverse of can be extended.,0,0,0
Feature Groups and Feature Group Types,p82l4,(L4)  A feature group type that is an extension of another feature group type without an inverse of cannot contain an inverse of statement.,0,0,0
Feature Groups and Feature Group Types,p82l5,(L5)  The feature group type that is an extension of another feature group type with features and inverse of that adds features must have an inverse of to identify the feature group type whose inverse it is.,0,0,0
Feature Groups and Feature Group Types,p82l6,(L6)  A feature group declaration with an inverse of statement must only reference feature group types without an inverse of statement.,0,0,0
Feature Groups and Feature Group Types,p82l7,(L7)  A feature group refinement may be refined to only add property associations. In this case inclusion of the feature group type reference is optional. Two feature group types are considered to complement each other if the following holds:,0,0,0
Feature Groups and Feature Group Types,p82l8,(L8)  The number of feature or feature groups contained in the feature group and its complement must be identical;,0,0,0
Feature Groups and Feature Group Types,p82l9,"(L9)  Each of the declared features or feature groups in a feature group must be a pair-wise complement with that in the feature group complement, with pairs determined by declaration order. In the case of feature group type extensions, the feature and feature group declarations in the extension are considered to be declared after the declarations in the feature group type being extended;",0,0,0
Feature Groups and Feature Group Types,p82l10,"(L10) If both feature group types have zero features, then they are considered to complement each other;",0,0,0
Feature Groups and Feature Group Types,p82l11,(L11) Ports are pair-wise complementary if they satisfy the port connection rules specified in Section 9.2.1. This includes  appropriate port direction and matching of data component classifier references according to classifier matching rules (see Section 9.5 legality rules (L3) and (L4);,0,0,0
Feature Groups and Feature Group Types,p82l12,(L12) Access features are pair-wise complementary if they satisfy the access connection rules in Section 9.4.,0,0,0
Feature Groups and Feature Group Types,p82l13,"(L13) If an in or out direction is specified as part of a feature group declaration, then all features inside the feature group  must satisfy this direction.",0,0,0
Ports,p83n1,(N1)  A defining port identifier must adhere to the naming rules specified for all features (see Section 8).,0,0,0
Ports,p83n2,(N2)  The defining identifier of a port refinement declaration must also appear in a feature declaration of a component type being extended and must refer to a port or an abstract feature.,0,0,0
Ports,p83n3,"(N3)  The unique component type identifier of the data classifier reference must be the name of a data component type. The data implementation identifier, if specified, must be the name of a data component implementation associated with the data component type.",0,0,0
Ports,p83n4,"(N4)  The prototype identifier of a prototype reference, if specified, must exist in the namespace of the component type or feature group type that contains the feature declaration.",0,0,0
Ports,p83l1,"(L1)  Ports can be declared in subprogram, thread, thread group, process, system, processor, virtual processor, and device component types.",0,0,0
Ports,p83l2,(L2)  Data and event data ports may be incompletely defined by not specifying the data component classifier reference or data component implementation identifier of a data component classifier reference. The port definition can be completed using refinement.,0,0,0
Ports,p83l3,"(L3)  Data, event, and event data ports may be refined by adding a property association. The data component classifier declared as part of the data or event data port declaration being refined does not need to be included in this refinement.",0,0,0
Ports,p83l4,"(L4)  The port category of a port refinement must be the same as the category of the port being refined, or the port being refined must be an abstract feature.",0,0,0
Ports,p83l5,"(L5)  The port direction of a port refinement must be the same as the direction of the feature being refined. If the feature being refined is an abstract feature without direction, then all port directions are acceptable.",0,0,0
Subprogram and Subprogram Group Access,p84n1,(N1)  The defining identifier of a provides or requires subprogram or subprogram group access declaration must be unique within the namespace of the component type where the subcomponent access is declared.,0,0,0
Subprogram and Subprogram Group Access,p84n2,(N2)  The defining identifier of a provides or requires subprogram or subprogram group refinement must exist as a defining identifier of a provides or requires subprogram or subprogram group or an abstract feature in the namespace of the component type being extended.,0,0,0
Subprogram and Subprogram Group Access,p84n3,"(N3)  The component type identifier or component implementation name of a subprogram or subprogram group access classifier reference, if present, must exist in the package namespace.",0,0,0
Subprogram and Subprogram Group Access,p84n4,"(N4)  The prototype identifier of a subprogram or subprogram group access classifier reference, if present, must exist in the namespace of the classifier that contains the access declaration.",0,0,0
Subprogram and Subprogram Group Access,p84l1,"(L1)  If a subprogram access refers to a component classifier or a component prototype, then the category of the classifier or prototype must be subprogram.",0,0,0
Subprogram and Subprogram Group Access,p84l2,"(L2)  If a subprogram group access refers to a component classifier or a component prototype, then the category of the classifier or prototype must be subprogram group.",0,0,0
Subprogram and Subprogram Group Access,p84l3,"(L3)  An abstract feature can be refined into a subprogram access or a subprogram group access. In this case, the abstract feature must not have a direction specified.",0,0,0
Subprogram and Subprogram Group Access,p84l4,(L4)  A subprogram or subprogram group access declaration that does not specify a component classifier reference is incomplete. Such a reference can be added in a subprogram or subprogram group access refinement declaration.,0,0,0
Subprogram and Subprogram Group Access,p84l5,(L5)  A subprogram or subprogram group access declaration may be refined by adding a property association. Inclusion of the component classifier reference is optional.,0,0,0
Subprogram and Subprogram Group Access,p84l6,"(L6)  A provides subprogram access cannot be refined to a requires subprogram access and a requires subprogram access cannot be refined to a provides subprogram access. Similarly, a provides subprogram group access cannot be refined to a requires subprogram group access and a requires subprogram group access cannot be refined to a provides subprogram group access.",0,0,0
Subprogram and Subprogram Group Access,p84c1,"(C1) A provides subprogram access feature indicates that a subprogram is made available to be referenced. A project  may enforce a consistency rule that a subprogram access connection connects this feature to directly a subprogram subcomponent, or indirectly via a requires subprogram (group) access or provides subprogram (group) access.",0,0,0
Subprogram Parameters,p85n1,(N1)  The defining identifier of a parameter must be unique within the namespace of the subprogram type containing the parameter declaration.,0,0,0
Subprogram Parameters,p85n2,(N2)  The defining parameter identifier of a parameter refinement declaration must also appear in a feature declaration of a component type being extended and must refer to a parameter or an abstract feature.,0,0,0
Subprogram Parameters,p85n3,(N3)  The data classifier reference must refer to a data component type or a data component implementation.,0,0,0
Subprogram Parameters,p85n4,"(N4)  The prototype identifier, if present, must exist in the namespace of the subprogram classifier that contains the parameter declaration.",0,0,0
Subprogram Parameters,p85l1,(L1)  Parameters can be declared for subprogram component types.,0,0,0
Subprogram Parameters,p85l2,(L2)  A parameter declaration that does not specify a data classifier reference is incomplete. Such a reference can be added in a parameter refinement declaration.,0,0,0
Subprogram Parameters,p85l3,(L3)  A parameter declaration may be refined by adding a property association. Inclusion of the data classifier reference is optional.,0,0,0
Subprogram Parameters,p85l4,"(L4)  The parameter direction of a parameter refinement must be the same as the direction of the feature being refined. If the feature being refined is an abstract feature without direction, then all parameter directions are acceptable.",0,0,0
Data Component Access,p86n1,(N1)  The defining identifier of a provides or requires data access declaration must be unique within the namespace of the component type where the data access is declared.,0,0,0
Data Component Access,p86n2,(N2)  The defining identifier of a provides or requires data access refinement must exist as a defining identifier of a provides or requires data access or as a defining identifier of an abstract feature in the namespace of the component type being extended.,0,0,0
Data Component Access,p86n3,(N3)  The component type identifier or component implementation name of a data access classifier reference must exist in the package namespace.,0,0,0
Data Component Access,p86n4,"(N4)  The prototype identifier, if present, must exist in the namespace of the classifier that contains the data access declaration.",0,0,0
Data Component Access,p86l1,"(L1)  If a data access refers to a component classifier or a component prototype, then the category of the classifier or prototype must be of category data.",0,0,0
Data Component Access,p86l2,"(L2)  A data access declaration may be refined by refining the data classifier, by adding a property association, or by doing both. If the refinement only adds a property association the classifier reference is optional.",0,0,0
Data Component Access,p86l3,(L3)  A provides data access cannot be refined to a requires data access and a requires data access cannot be refined to a provides data access.,0,0,0
Data Component Access,p86l4,"(L4)  An abstract feature can be refined into a data access. In this case, the abstract feature must not have a direction specified.",0,0,0
Data Component Access,p86c1,(C1) A data access declaration that does not specify a data classifier reference is incomplete. Such a reference can be  added in a data access refinement declaration.,0,0,0
Data Component Access,p86c2,"(C2) If the source code of a component does access shared data, then the component type declaration must specify a  requires data access declaration. In other words, for all components that access shared data their component type declaration must reflect that fact.",0,0,0
Data Component Access,p86c3,"(C3) A data access refinement may refine an abstract feature declaration. If the abstract feature declaration specifies a  direction of in, then the access right of the data access must be read-only. If the direction is out, then the access right of the data access must be write-only. If the abstract feature does not have a specified direction, then any access right is acceptable.",0,0,0
Bus Component Access,p87n1,(N1)  The defining identifier of a provides or requires bus access declaration must be unique within the namespace of the component type where the bus access is declared.,0,0,0
Bus Component Access,p87n2,(N2)  The defining identifier of a provides or requires bus refinement must exist as a defining identifier of a requires or provides bus access or of an abstract feature in the namespace of the component type being extended.,0,0,0
Bus Component Access,p87n3,(N3)  The component type identifier or component implementation name of a bus access classifier reference must exist in the package namespace.,0,0,0
Bus Component Access,p87n4,"(N4)  The prototype identifier, if present, must exist in the namespace of the classifier that contains the bus access declaration.",0,0,0
Bus Component Access,p87l1,"(L1)  If a bus access refers to a component classifier or a component prototype, then the category of the classifier or prototype must be of category bus.",0,0,0
Bus Component Access,p87l2,"(L2)  A bus access declaration may be refined by refining the bus classifier, by adding a property association, or by doing both. If the refinement only adds a property association the bus classifier reference is optional.",0,0,0
Bus Component Access,p87l3,(L3)  A provides bus access cannot be refined to a requires bus access and a requires bus access cannot be refined to a provides bus access.,0,0,0
Bus Component Access,p87l4,"(L4)  An abstract feature can be refined into a bus access. In this case, the abstract feature must not have a direction specified.",0,0,0
Bus Component Access,p87c1,(C1) A bus access declaration that does not specify a bus classifier reference is incomplete. Such a reference can be  added in a bus access refinement declaration.,0,0,0
Bus Component Access,p87c2,"(C2) If a bus access feature is a refinement of an abstract feature, then the direction of the abstract feature, if specified,  imposes a restriction on the access right, i.e., in implies read-only, and out implies write-only.",0,0,0
Bus Component Access,p87n1,"(N1)  The defining identifier of a defined connection declaration must be unique in the local namespace of the component implementation with the connection subclause. This is also the case for mode-specific connection declarations, i.e., declarations with an in_modes_and_transition subclause.",0,0,0
Bus Component Access,p87n2,(N2)  The connection identifier in a connection refinement declaration must refer to a named connection declared in an ancestor component implementation.,0,0,0
Bus Component Access,p87l1,"(L1)  A connection refinement must contain at least one of the following: a connection source and destination subclause, a property association, an in modes subclause.",0,0,0
Bus Component Access,p87l2,"(L2)  If a semantic connection may be active in a particular mode, then the ultimate source and ultimate destination components must be part of that mode.",0,0,0
Bus Component Access,p87l3,"(L3)  If a semantic connection may be active in a particular mode transition, then the ultimate source component must be part of a system mode that includes the old mode identifier and the ultimate destination component must be part of a system mode that includes the new mode identifier.",0,0,0
Feature Connections,p91n1,"(N1)  A source or destination reference in a feature connection or feature connection refinement declaration must reference a feature declared in the component type, a feature in a feature group of the component type, or a feature of one of the subcomponents. The source and destination features must be abstract features, ports, parameters, or access features.",0,0,0
Feature Connections,p91n2,(N2)  The subcomponent reference may refer to a subcomponent or a subcomponent array.,0,0,0
Feature Connections,p91l1,"(L1)  If the feature connection declaration represents a connection between features of sibling components, then the source must be an outgoing feature and the destination must be an incoming feature. An outgoing feature is an abstract feature with no direction or out direction, an outgoing port or parameter with an out or in out direction, or an access feature, in the case of data access with at least write access. An incoming feature is an abstract feature with no direction or in direction, an incoming port or parameter with an in or in out direction, or an access feature, in the case of data access with at least read access.",0,0,0
Feature Connections,p91l2,"(L2)  If the feature connection declaration represents a connection between features up the containment hierarchy, then the source and destination must both be outgoing features.",0,0,0
Feature Connections,p91l3,"(L3)  If the feature connection declaration represents a connection between features down the containment hierarchy, then the source and destination must both be incoming features.",0,0,0
Feature Connections,p91l4,"(L4)  If the feature connection declaration specifies a directional connection, then the direction of the connection must be supported by the direction of the source and destination features.",0,0,0
Feature Connections,p91l5,(L5)  The individual connections of a semantic connection must be bidirectional or have the same direction. The direction of the connection is determined by the direction of the source and destination feature and by the direction of the connection declarations.,0,0,0
Port Connections,p92n1,(N1)  The connection identifier in a port connection refinement declaration must refer to a named port or feature connection declared in an ancestor component implementation.,0,0,0
Port Connections,p92n2,"(N2)  A source or destination reference in a port connection or port connection refinement declaration must reference a port declared in the component type, a port of one of the subcomponents, or a port that is an element of a feature group in the component type, or it must refer to a requires data access in the component type, a provides data access in one of the subcomponents, or a data subcomponent.",0,0,0
Port Connections,p92n3,(N3)  The subcomponent reference may also consist of a reference to a subcomponent array.,0,0,0
Port Connections,p92n4,(N4)  The event_or_event_data identifier of event source specifications (self.event_or_event_data_identifier) must not conflict with defining identifiers in the namespace of the component that contains the connection referencing the event source.,0,0,0
Port Connections,p92l1,(L1)  In the case of a directional port connection the connection end representing the source of the flow must be the source of the connection and the connection end representing the destination of the flow must be the destination of the connection.,0,0,0
Port Connections,p92l2,"(L2)  In the case of a bidirectional port connection either connection end can be the source. If the bidirectional connection has directional connection ends, then the flow is determined by the direction of the connection ends. In the case of ports it is the port direction and in the case of data access features it is the access right.",0,0,0
Port Connections,p92l3,(L3)  If the source connection end is a data access feature it must have read access rights; if the destination connection end is a data access feature it must have write access rights.,0,0,0
Port Connections,p92l4,"(L4)  The feature identifier of a subcomponent reference may refer to a feature array, if the subcomponent is a thread, device, or processor.",0,0,0
Port Connections,p92l5,"(L5)  The following are acceptable sources and destinations of port connections. The left column shows connections between ports, while the right column shows connection between ports and data components. event port -> event port data port -> data port, event data port, event port event data port -> event data port, data port, event port data, data access -> data port, event data port, event port data port, event data port -> data, data access SAE AS5506B - 162 - The direction of the source port of a port connection declaration must be compatible with the direction of the destination port as defined by the following rules:",0,0,0
Port Connections,p92l6,"(L6)  If the port connection declaration represents a connection between ports of sibling components, then the source must be an outgoing port and the destination must be an incoming port. If the source connection end is a data access feature, then it must be a provides access feature; if it is a destination connection end it must be a requires access feature.",0,0,0
Port Connections,p92l7,"(L7)  If the port connection declaration represents a connection between ports up the containment hierarchy, then the source and destination must both be outgoing ports. If the source connection end is a data access feature, then it must be a provides access feature; if it is a destination connection end it must be a requires access feature.",0,0,0
Port Connections,p92l8,"(L8)  If the port connection declaration represents a connection between ports down the containment hierarchy, then the source and destination must both be incoming ports. If the source connection end is a data access feature, then it must be a requires access feature; if it is a destination connection end it must be a provides access feature.",0,0,0
Port Connections,p92l9,(L9)  The individual connections of a semantic port connection must be bidirectional or have the same direction. The direction of the connection is determined by the direction of the source and destination feature and by the direction of the connection declarations.,0,0,0
Port Connections,p92l10,(L10) Self.<identifier> must only be referenced as the source of a connection.,0,0,0
Port Connections,p92l11,(L11) A data port cannot be the destination of more than one semantic port connection unless each semantic port  connection is contained in a different mode.,0,0,0
Port Connections,p92l12,(L12) A semantic connection cannot contain connection declarations with both immediate and delayed Timing property  values.,0,0,0
Port Connections,p92l13,"(L13) For connections between data ports, event data ports and data access, the data classifier of the source port must  match the data type of the destination port. The Classifier_Matching_Rule property specifies the rule to be applied to match the data classifier of a connection source to the data classifier of a connection destination.",0,0,0
Port Connections,p92l14,"(L14) The following rules are supported:  вЂў вЂў вЂў вЂў Classifier_Match: The source data type and data implementation must be identical to the data type or data implementation of the destination. If the destination classifier is a component type, then any implementation of the source matches. This is the default rule. Equivalence: An indication that the two classifiers of a connection are considered to match if they are listed in the Supported_Classifier_Equivalence_Matches property. Acceptable data classifier matches are specified as Supported_Classifier_Equivalence_Matches property with pairs of classifier values representing acceptable matches. Either element of the pair can be the source or destination classifier. Equivalence is intended to be used when the data types are considered to be identical, i.e., no conversion is necessary. The Supported_Classifier_Equivalence_Matches property is declared globally as a property constant. Subset: A mapping of (a subset of) data elements of the source port data type to all data elements of the destination port data type. Acceptable data classifier matches are specified Supported_Classifier_Subset_Matches property with pairs of classifier values representing acceptable matches. The first element of each pair specifies the acceptable source classifier, while the second element specifies the acceptable destination classifier. The Supported_Classifier_Subset_Matches property is declared globally as a property constant. A virtual bus or bus must represent a protocol that supports subsetting, such as OMG DDS. Conversion: A mapping of the source port data type to the destination port data type, where the source port data type requires a conversion to the destination port data type. Acceptable data classifier matches are specified as Supported_Type_Conversions property with pairs of classifier values representing acceptable matches. The first element of each pair specifies the acceptable source classifier, while the second element specifies the acceptable destination classifier. The Supported_Type_Conversions property may be declared globally as a property constant. A virtual bus or bus must support the conversion from the source data classifier to the destination classifier. SAE AS5506B - 163 -",0,0,0
Port Connections,p92l15,"(L15) If more than one port connection declaration in a semantic port connection has a property association for a given  connection property, then the resulting property values must be identical.",0,0,0
Port Connections,p92l16,(L16) A processor port specification must only be used in event connections within threads and subprograms.,0,0,0
Port Connections,p92c1,"(C1) There cannot be cycles of immediate connections between threads, devices, and processors.",0,0,0
Port Connections,p92c2,(C2) The processor port identifier of a processor port specification (processor.processor_port_identifier) must name a  port of the processor that the thread is bound to.,0,0,0
Port Connections,p92c3,(C3) The Supports_Classifier_Subset_Matches property may be associated with a bus or virtual bus. This  specifies the subset matches a particular protocol supports. Subset matches of connections bound to such a virtual bus or bus must be supported by the respective virtual bus or bus.,0,0,0
Port Connections,p92c4,(C4) The Supports_Type_Conversions property may be associated with a bus or virtual bus. This specifies the  subset matches a particular protocol supports. Subset matches of connections bound to such a virtual bus or bus must be supported by the respective virtual bus or bus.,0,0,0
Parameter Connections,p93n1,(N1)  The connection identifier in a parameter connection refinement declaration must refer to a named parameter or feature connection declared in an ancestor component implementation.,0,0,0
Parameter Connections,p93n2,"(N2)  A source (destination) reference in a parameter connection declaration must reference a parameter of a preceding (succeeding) subprogram call, a parameter declared in the component type of the containing subprogram, a data port or event data port declared in the component type of the enclosing thread, a data port or event data port that is an element of a feature group in the component type of the enclosing thread, a data subcomponent, or a requires data access to a data component.",0,0,0
Parameter Connections,p93l1,"(L1)  The source of a parameter connection must be an incoming data or event data port of the containing thread, an incoming parameter of the containing subprogram, or a data subcomponent or requires data access with read-only or read-write access rights, or an outgoing parameter of a previous subprogram call.",0,0,0
Parameter Connections,p93l2,(L2)  The following source/destination pairs are acceptable for parameter connection declarations: threadport -> call.parameter requiresdataaccess -> call.parameter threadfeaturegroup.port -> call.parameter featuregroup.requiresdataaccess -> call.parameter SAE AS5506B call.parameter -> threadport call.parameter -> requiresdataaccess call.parameter -> threadfeaturegroup.port call.parameter -> featuregroup.requiresdataaccess call.parameter -> threadincompletefeaturegroup call.parameter -> datasubcomponent containedcall.parameter -> parameter datasubcomponent -> call.parameter parameter -> containedcall.parameter call.parameter -> call.parameter - 173 -,0,0,0
Parameter Connections,p93l3,"(L3)  A parameter cannot be the destination feature reference of more than one parameter connection declaration unless the source feature reference of each parameter connection declaration is contained in a different mode. In this case, the restriction applies for each mode.",0,0,0
Parameter Connections,p93l4,(L4)  The data classifier of the source and destination must match. The matching rules as specified by the Classifier_Matching_Rule property apply (see Section 9.2 (L13)). By default the data classifiers must be match.,0,0,0
Access Connections,p94n1,(N1)  The connection identifier in an access connection refinement declaration must refer to a named access or feature connection declared in an ancestor component implementation.,0,0,0
Access Connections,p94n2,"(N2)  An access reference in an access connection declaration must reference an access feature of a subcomponent, subprogram call, or processor, an access feature in the component type of the containing component, an access feature in a feature group of the containing component type, or a data, bus, subprogram, or subprogram group subcomponent.",0,0,0
Access Connections,p94l1,"(L1)  The category of the source and the destination of a access connection declaration must be the same, i.e., they must both be data, bus, subprogram, or subprogram group, or their respective access feature.",0,0,0
Access Connections,p94l2,(L2)  In the case of a bidirectional semantic access connection either connection end can be the source.,0,0,0
Access Connections,p94l3,"(L3)  In the case of a directional data or bus access connection the connection end representing the component being accessed must be the source for read access, and the destination for write access, i.e., the direction declared for the access connection must be compatible with the direction of the data flow for reading or writing based on the access rights.",0,0,0
Access Connections,p94l4,(L4)  In a partial AADL model the ultimate source or destination may be a provides access feature of a component instead of the subcomponent. The provides and requires indicators of source and destination access features must satisfy the following rules:,0,0,0
Access Connections,p94l5,"(L5)  If the access connection declaration represents an access connection between access features of sibling components, then the source must be a provides access, and the destination must be a requires access.",0,0,0
Access Connections,p94l6,"(L6)  If the access connection declaration represents a feature mapping up the containment hierarchy, then one connection end must be a provides access of a subcomponent, or a data, subprogram, or bus subcomponent; and the other connection end must be a provides access feature of the enclosing component or a provides feature of a feature group of the enclosing component.",0,0,0
Access Connections,p94l7,"(L7)  If the access connection declaration represents a feature mapping down the containment hierarchy, then one connection end must be a requires access of the enclosing component, a requires access of a feature group of the enclosing component, or a data, subprogram, or bus subcomponent; and the other connection end must be a requires access of a subcomponent.",0,0,0
Access Connections,p94l8,"(L8)  A requires access cannot be the source or destination feature reference of more than one access connection declaration unless the source feature reference(s) of each access connection declaration is (are) contained in a different mode. In this case, the restriction applies for each mode.",0,0,0
Access Connections,p94l9,(L9)  For access connections the classifier of the provider access must match to the classifier of the requires access according to the Classifier_Matching_Rules property. By default the classifiers must be the same (see Section 9.1). SAE AS5506B - 176 -,0,0,0
Access Connections,p94l10,"(L10) If more than one access feature in a semantic access connection has an Access_Right property association,  then the resulting property values must be compatible. This means that the provider must provide read-only or read-write access if the requirer specifies read-only. Similarly, the provider must provide write-only or read-write access if the requirer specifies write-only. The provider must provide read-write access if the requirer specifies read-write. Finally, the provider must provide by-method access if the requirer specifies bymethod access.",0,0,0
Access Connections,p94l11,"(L11) The category of the access connection source and destination must be identical. If the component category is  specified as part of the connection declaration, then it must be identical to that of the source and destination. Bus, data, subprogram, and subprogram group are acceptable categories.",0,0,0
Feature Group Connections,p95n1,(N1)  The connection identifier in a feature group connection refinement declaration must refer to a feature group named connection declared in an ancestor component implementation.,0,0,0
Feature Group Connections,p95n2,"(N2)  A source or destination reference in a feature group connection declaration must reference a feature group declared in the component type, a feature group of one of the subcomponents, or feature group that is an element of a feature group in the component type. The subcomponent reference may also consist of a reference on a subcomponent array.",0,0,0
Feature Group Connections,p95l1,"(L1)  If the feature group connection declaration represents a component connection between sibling components, the feature group types must be complements. This may be indicated by both feature group declarations referring to the same feature group type and one feature group declared as inverse of, by the feature group type of one feature group being declared as the inverse of the feature group type of the other feature group, or by the two referenced feature group types meeting the complement requirements as defined in Section 8.2.",0,0,0
Feature Group Connections,p95l2,(L2)  The Classifier_Matching_Rule property specifies the rule to be applied to match the feature group classifier of a connection source to that of a connection destination.,0,0,0
Feature Group Connections,p95l3,"(L3)  The following rules are supported for feature group connection declarations that represent a connection up or down the containment hierarchy: вЂў вЂў вЂў Classifier_Match: The source feature group type must be identical to the feature group type of the destination. This is the default rule. Equivalence: An indication that the two classifiers of a connection are considered to match if they are listed in the Supported_Classifier_Equivalence_Matches property. Matching feature group types are specified by the Supported_Classifier_Equivalence_Matches property with pairs of classifier values representing acceptable matches. Either element of the pair can be the source or destination classifier. Equivalence is intended to be used when the feature group types are considered to be identical, i.e., their elements match. The Supported_Classifier_Equivalence_Matches property is declared globally as a property constant. Subset: An indication that the two classifiers of a connection are considered to match if the outer feature group has outcoming features that are a subset of outgoing features of the inner feature group, and if the inner feature group has incoming features that are a subset of incoming features of the outer feature group. The pairs of features are expected to have the same name. SAE",0,0,0
Feature Group Connections,p95l4,"(L4)  AS5506B - 178 - The following rules are supported for feature group connection declarations that represent a connection between two subcomponents, i.e., sibling component: вЂў вЂў вЂў Classifier_Match: The source feature group type must be the complement of the feature group type of the destination. This is the default rule. Complement: An indication that the two classifiers of a connection are considered to complement if they are listed in the Supported_Classifier_Complement_Matches property. Matching feature group types are specified by the Supported_Classifier_Complement_Matches property with pairs of classifier values representing acceptable matches. Either element of the pair can be the source or destination classifier. Complement is intended to be used when the feature group types are considered to be identical, i.e., their elements match. The Supported_Classifier_Complement_Matches property is declared globally as a property constant. Subset: An indication that the two classifiers of a connection are considered to match if each has incoming features that are a subset of outgoing features of the other. The pairs of features are expected to have the same name. A feature group may have a direction declared; otherwise it is considered bidirectional. The direction declared for the destination feature group of a feature group connection declaration must be compatible with the direction declared for the source feature group as defined by the following rules:",0,0,0
Feature Group Connections,p95l5,"(L5)  If the feature group connection declaration represents a connection between feature group of sibling components, then the source must be an outgoing feature group and the destination must be an incoming feature group.",0,0,0
Feature Group Connections,p95l6,"(L6)  If the feature group connection declaration represents a connection between feature groups up the containment hierarchy, then the source and destination must both be an outgoing feature group.",0,0,0
Feature Group Connections,p95l7,"(L7)  If the feature group connection declaration represents a connection between feature groups down the containment hierarchy, then the source and destination must both be an incoming feature group.",0,0,0
Feature Group Connections,p95l8,"(L8)  A feature group connection must be bidirectional or be consistent with the direction of the source and destination feature. Standard Properties Connection_Pattern: list of Supported_Connection_Patterns Connection_Set: list of Connection_Pair Transmission_Type: enumeration ( push, pull ) Allowed_Connection_Binding_Class: inherit list of classifier(processor, virtual processor, bus, virtual bus, device, memory) Allowed_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory) Not_Collocated: record ( Targets: list of reference (data, thread, process, system, connection); Location: classifier ( processor, memory, bus, system ); ) Actual_Connection_Binding: inherit list of reference (processor, virtual processor, bus, virtual bus, device, memory)",0,0,0